---
title: "Aim3_Leaf_traits_Statistical_Analyses"
author: "Bolívar Aponte Rolón"
date: "Last edited: `r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document: 
    toc: true
    toc_depth: 4
    toc_float: true
    number_sections: true
    highlight: espresso
    theme: journal
    code_folding: hide

---
```{r setup}
knitr::opts_chunk$set(out.width ='70%', fig_align = 'center', echo = TRUE, collapse = TRUE)
```


This are the statistical analyses for Aim 3 Leaf Traits and Endophytes project with Sunshine Van Bael from Tulane University, and E.A. Arnold from the University of Arizona. The bioinformatic analyses and data files (e.g., .csv) produced are a product of files *Aim3_Sequence_Data_Cleaning.R* and *Aim_3_Prelim_analyses_9SEPT2020.Rmd*. The first file, cleans and shapes the OTU files produced from the bioinformatic analyses completed with VSEARCH. The taxonomic assignment was completed with T-BAS. The second file explores correlations and distributions of covariates for this project.


# R packages used
Not all of these packages are used. They are here just in case need further along the analyses.

```{r, message = FALSE}
# Data manipulation and visualizations ####
library("conflicted")
library("devtools")
library("DiagrammeR")
library("factoextra")
library("ggfortify")
library("ggiraph")
library("ggiraphExtra")
library("ggplot2")
library("ggpubr")
library("gridExtra")
library("ggthemes")
library("ggraph")
library("hrbrthemes")
library("igraph")
library("tidyverse")
library("plotrix")
library("viridis")
library("MetBrewer")
library("formatR")
library("wesanderson")
library("knitr")
library("rmarkdown")
library("data.table")

# Stats ####
library("vegan")
library("nlme")
library("MASS")
library("car") #For type 3 Anova with Anova() function.
library("PerformanceAnalytics")
library("corrr")
library("permute")
library("lattice")
library("pls")
library("buildmer")
library("lme4")
library("sjPlot")
library("glmmTMB")
library("indicspecies")

# Phylogenetic analyses ####
#source("https://raw.githubusercontent.com/joey711/phyloseq/master/inst/scripts/installer.R",local = TRUE)
library("mgcv")
library("phyloseq")
library("ape")
library("metagMisc")
# remotes::install_github("vmikk/metagMisc")
library("speedyseq")
library("picante")
#source("http://bioconductor.org/biocLite.R")


# Preference of conflicted functions among packages ####
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer_all("phyloseq")
```

# Working Directory

```{r}
rm(list = ls()) 
#setwd("H:/.shortcut-targets-by-id/0B9v0CdUUCqU5VVR4a3BvNHM1Z28/VBL_users/Grad_Students/Bolivar/Dissertation/Leaf_Traits_Panama/Data/Sequence_analyses")

setwd("C:/Users/boloq/Box/Dissertation/Leaf_Traits_Panama/Data/Aim3_Sequence_analyses")
save.path <- "C:/Users/boloq/Box/Dissertation/Leaf_Traits_Panama/Data/Aim3_Sequence_analyses"
```

# Data frames

Data frames needed for diversity, abundance, and richness analyses. Clean sample sequences data (no contaminants). T-BAS taxonomic assignment and leaf traits data set. 

```{r, Clean sequences, tidy = TRUE}
set.seed(123)
# Cleaned (decontaminated) sample sequences ####
#csamp
# csamp <- read.csv("all_cleaned_at_10_percent.csv")
# csamp[,2:157] <- lapply(csamp[,2:157], as.integer)
# csamp <- csamp %>%
#   rename(OTU_ID = X) %>%
#   column_to_rownames(var = "OTU_ID") %>%
#   na.omit() %>%
#   na.fail() %>%
#   as.matrix()

# Saving
# saveRDS(csamp, file.path(save.path, "R_objects", "clean_sequences.rds"))

# Reading
csamp <- readRDS(file.path(save.path, "R_objects", "clean_sequences.rds"))
```

```{r, TBAS, tidy = TRUE}
# T-BAS taxonomic assignment ####
#tbas
# tbas <- read.csv("unite_report2BSDHQZP.csv")
# tbas <- tbas %>%
#   dplyr::filter(phylum == "Ascomycota") %>%
#   select(-match,-e.value, -percent, -coverage, -bitscore) %>% #eliminating some columns that I am not really using
#   na.omit()%>%
#   rename( OTU_ID = query) %>%
#   column_to_rownames(var = "OTU_ID") %>%
#   na.omit() %>%
#   na.fail() %>%
#   as.matrix()

# Saving
#saveRDS(tbas, file.path(save.path, "R_objects", "tbas_filtered.rds"))

# Reading
tbas <- readRDS(file.path(save.path, "R_objects", "tbas_filtered.rds"))
```

```{r, Leaf trait variables data, tidy = TRUE}
# data

data <- read.csv("Aim3_Bolivar_Summer_2019_Leaf_Traits_datasheet.csv")

# data2
# Data set created on May 23, 2023 for analysis with raw data.
# data2 <- data %>% 
#   separate(Unique_ID, c("Trial_Code", "ELoad", "Species2", "Replicate")) %>%
#   unite("Sample_name", Species2:Replicate, sep = "") %>%
#   relocate(Sample_name, Trial_Code, E_load, .after = Species) %>%
#   select(!c(5, 15:17, 20)) %>%
#   rename( Anthocyanins = Anthocyanins..aci., 
#           Thickness = Thickness..micro.m.,  
#           Toughness =Toughness..lbf., 
#           LMA = LMA_dw, 
#           Abun_3 = Abundance_Proportion_day3, 
#           Abun_7 = Abundance_Proportion_day7)

# Saving
# saveRDS(data2, file.path(save.path, "R_objects", "leaf_data_raw_analyses.rds"))

# Reading
data2 <- readRDS(file.path(save.path, "R_objects", "leaf_data_raw_analyses.rds"))

# ndata (new_data)
# This data set can also be used to conduct analysis with "raw" data . It is summarized by leaf.

# ndata <- data %>%  
#   group_by(Species, Unique_ID, Trial_type, E_load, Leaf_ID) %>%
#   summarise(Anthocyanins..aci. = mean(Anthocyanins..aci., na.rm = TRUE), 
#             Thickness..micro.m. = mean(Thickness..micro.m., na.rm = TRUE),
#             Toughness..lbf. = mean(Toughness..lbf., na.rm = TRUE),
#             LMA_dw = mean(LMA_dw, na.rm = TRUE),
#             Abundance_Proportion_day3 = mean(Abundance_Proportion_day3, na.rm = TRUE),
#             Abundance_Proportion_day7 = mean(Abundance_Proportion_day7, na.rm = TRUE)) %>%
#    separate(Unique_ID, c("Trial_Code", "ELoad", "Species2", "Replicate")) %>%
#   unite("Sample_name", Species2:Replicate, sep = "") %>%
#   relocate(Species, Trial_Code,.after = Sample_name) %>%
#   rename( Anthocyanins = Anthocyanins..aci., 
#           Thickness = Thickness..micro.m.,  
#           Toughness =Toughness..lbf., 
#           LMA = LMA_dw, 
#           Abun_3 = Abundance_Proportion_day3, 
#           Abun_7 = Abundance_Proportion_day7) %>%
#   select(!ELoad) %>%
#   ungroup() %>%
#    mutate_if(is.character, as.factor) %>%
#   na.omit() %>% 
#   na.fail()

# Saving
# saveRDS(ndata, file.path(save.path, "R_objects", "new_leaf_data.rds"))

# Reading
ndata <- readRDS(file.path(save.path, "R_objects", "new_leaf_data.rds"))

# Splitting and relocating Unique_ID column 
# Extract names to match to phyloseq objects separate(Species2, c("Species3", "Numbers"), sep = "(?<=[A-Za-z])(?=[0-9])")

# ndata2 (new_data2)
# Data frame is summarized by plant (n = 156)

# ndata2 <- ndata %>% 
#   select(!c(Abun_3, Abun_7)) %>%
#   mutate_if(is.character, as.factor) %>%
#   group_by(Sample_name, Species, Trial_type, Trial_Code, E_load) %>%
#   summarise(Anthocyanins = mean(Anthocyanins, na.rm = TRUE),
#             Thickness = mean(Thickness, na.rm = TRUE),
#             Toughness = mean(Toughness, na.rm =TRUE),
#             LMA = mean(LMA, na.rm = TRUE)) 

# Saving
# saveRDS(ndata2, file.path(save.path, "R_objects", "new_leaf_data2.rds"))

# Reading
ndata2 <- readRDS(file.path(save.path, "R_objects", "new_leaf_data2.rds"))

# Glimpse
glimpse(data)
glimpse(csamp)
glimpse(tbas)
glimpse(ndata)
glimpse(ndata2)

```

### Ant and Pathogen assay data

For this data set I have calculated the area or percent area loss of leaf by the ants. I need to calculate the rate of loss. **How fast did the ants cut off leaf matter?**
This data set also need cleaning and calculation of other variables. **How fast did the pathogen spread?**

The code below cleans the `ants` data set by removing all the variables with incomplete data or not important for our current analyses. Additionally it eliminates unsuccessful trials (labeled by 0 in Trial_success) as well a trial # 10 which is missing data for one of the treatments. It is important to remove the trial as a whole to be able to performed paired t-tests.

```{r, Ant assay data, tidy = TRUE}

# ants <- read.csv("Aim3_Bolivar_Summer_2019_Ant_Assay_datasheet.csv")
# 
# ants <- ants %>%
#   separate(Unique.ID, c("Trial_Code", "ELoad", "Species2", "Replicate")) %>%
#   unite("Sample_name", Species2:Replicate, sep = "") %>%
#   relocate(Species, Trial_Code,.after = Sample_name)%>%
#   slice(-c(11,12)) %>%
#   dplyr::filter(Trial_success!="0") %>%
#   select(!c(Leaf_ID, 
#             Colony_ID, 
#             Picture_ID, 
#             Colony_location_Pipeline.Gamboa, 
#             Attempt, 
#             Date_analyzed, 
#             X_coordinates, 
#             Y_coordinates, 
#             Elevation_meters, 
#             ELoad, 
#             Analyzer, 
#            
#             Time_start_trial, 
#             Time_first_contact, 
#             Time_first_cut, 
#             Time_end_elapsed_trial )) %>%
#   mutate(Ant_percent_leafloss = -100*{(Leaf_area_final-Leaf_area_initial)/Leaf_area_initial}) %>%
#   mutate_if(is.character, as.factor)

# Saving
# saveRDS(ants, file.path(save.path, "R_objects", "ants_data.rds"))

# Reading
ants <- readRDS(file.path(save.path, "R_objects", "ants_data.rds"))


# Just the area loss
ants2 <- ants %>%
  select(c(1,3,4,9,10))

ants3 <- ants %>%
  select(c(1,3,4,5,9,10))


# Glimpse
 glimpse(ants)
 glimpse(ants2)
 kable(head(ants2))
```


I removed rows for trials T1-T2 of THEO samples and T5 of APEIME samples (rows 41:48, 97:100, respectively). Removing these Trials because they have missing data and they are paired. Only removing the row with missing data would create an uneven paired data set. Making paired t-tests troublesome.

```{r, Pathogen Assay Data, tidy = TRUE}

# patho <- read.csv("Aim3_Bolivar_Summer_2019_Patho_Assay_datasheet.csv")
# 
# patho <- patho %>%
#   separate(Unique.ID, c("Trial_Code", "ELoad", "Species2", "Replicate")) %>%
#   unite("Sample_name", Species2:Replicate, sep = "") %>%
#   relocate(Species, Trial_Code,.after = Sample_name) %>%
#   slice(-c(41:48, 97:100)) %>%
#   select(!c(ELoad,
#             Leaf_ID,
#             Trial_start_time,
#             Date, 
#             ImageJ_link, 
#             X, 
#             Notes)) %>%
#   rename(Treatment = Treatment_Ctrl_Pathogen) %>%
#   mutate(Pathogen_percent_damage = (Damage_area/Leaf_area)) %>%
#   mutate_if(is.character, as.factor)

# Saving
# saveRDS(patho, file.path(save.path, "R_objects", "pathogen_data.rds"))

# Reading
patho <- readRDS(file.path(save.path, "R_objects", "pathogen_data.rds"))


#Just the area damaged
patho2 <- patho %>%
  select(c(1,3,4,8,9,12))


patho3 <- patho %>%
  select(c(1,3,4,6,7,8,9,12))

#Glimpse
glimpse(patho)
glimpse(patho2)
kable(head(patho2))
```

# Taxonomical assignment of OTU's

The taxonomic assignment was completed with T-BAS. The 'unite_report" returned is what I used for creating the `phyloseq` objects. Here I bind the taxonomy, OTUs and sample metadata together. All is done with the `phyloseq` package. For reference <https://joey711.github.io/phyloseq/>.

## Phyloseq objects and dataframes
```{r, Objects and dataframes, tidy = TRUE}
### Phyloseq objects ####

# OTU Table: 1774 OTU with 156 Samples
# OTU <- otu_table(csamp, taxa_are_rows = TRUE)
# OTU

# Saving
# saveRDS(OTU, file.path(save.path, "R_objects", "otu_table.rds"))

# Taxonomic Table: 1707 OTU by 7 taxonomic ranks
# TAX <- tax_table(tbas)

# Saving
# saveRDS(TAX, file.path(save.path, "R_objects", "taxonomy_table.rds"))

# SAMP (sample metadata)

# SAMP <- ndata2 %>%
#   column_to_rownames(var = "Sample_name")
# SAMP <- sample_data(SAMP)

# Saving
# saveRDS(SAMP, file.path(save.path, "R_objects", "samp_data.rds"))


# # Merging phyloseq objects ####
# pq1 <- phyloseq(OTU, TAX, SAMP)

# Saving
# saveRDS(pq1, file.path(save.path, "R_objects", "phyloseq_main.rds"))

# Reading
pq1 <- readRDS(file.path(save.path, "R_objects", "phyloseq_main.rds"))

# Random tree ####
#random_tree <- rtree(ntaxa(pq), rooted=TRUE, tip.label=taxa_names(pq))

#write.nexus(random_tree, file = "random_tree.nex") #Creating nexus file to latter manipulate with FigTree software.
```

## Pre-processing: Ascomycota

**Code modified from Mareli Sánchez Juliá.**

Are there any taxa with no (0) reads?
#
```{r, Mareli code, tidy = TRUE}
#
# pq2 <- prune_taxa(taxa_sums(pq1) > 0, pq1)
# ntaxa(pq2) #There are 488 taxa with 0 reads.

# Saving
# saveRDS(pq2, file.path(save.path, "R_objects", "phyloseq_pq2.rds"))

# Reading
pq2 <- readRDS(file.path(save.path, "R_objects", "phyloseq_pq2.rds"))

# Subset of pq1 -- only E+ samples and OTUs.
#Important -- don't remove OTUs with 0 reads here, because we want to know which ones have no reads in E+ but DO have reads in E-.
pq2E <- subset_samples(pq2, E_load == "E+")
ntaxa(pq2E) #1219 taxa and 78 samples

# Eliminate E- only OTUs. Keep OTUs with more than 0 reads in subset.
pq2_EminusRemoved <- prune_taxa(taxa_sums(pq2E) > 0, pq2E)
ntaxa(pq2_EminusRemoved) #959 taxa remain. 260 OTUs removed.

#If OTU has 0 reads in E+, it will have reads in E-, so this prunes pq2E and identifies all OTUs that have 0 reads in E+, which by default, are the OTUs that DO have reads in E-.
pq2_EminuOnly <- prune_taxa(taxa_sums(pq2E) == 0, pq2E)
pq2_EminuOnly #260 taxa and 78 samples

# Gets names of OTUs and make a data frame with column name the same as in pq2
EminusOTUs2 <- taxa_names(pq2_EminuOnly)
EminusOTUsList2 <- as.data.frame(EminusOTUs2)
#write.table(EminusOTUsList2, "Aim3_RemovedOTUsList.txt")

# Get vectors (names) of numbered OTUs from pq1
OTU_ID <- rownames(otu_table(pq1))

# Returns all OTU names that don't have a match in Eminus OTUs.
notShared <- setdiff(OTU_ID, EminusOTUs2)

# Subset phyloseq object to only these OTUs
pq2ET <- subset(otu_table(pq2), rownames(otu_table(pq2)) %in% notShared)

# Exported into "Sequence Analyses"
#write.csv(pq2ET, "Aim3_OTU_phyloseq_trimmed.csv")

# New phyloseq object without E- OTUs.
newpq <- merge_phyloseq(pq2ET, tax_table(pq2), sample_data(pq2), rtree(ntaxa(pq2), rooted=TRUE, tip.label=taxa_names(pq2)))

# Relative Abundance of 959 OTUs. No removal of singletons yet.

# rawra <- transform_sample_counts(newpq, function(x)x/sum(x))
# rawRA <- subset(otu_table(rawra), rownames(otu_table(rawra)) %in% notShared)
# write.csv(rawRA, "Aim3_OTU_Relative_Abundance_singletons_untrimmed.csv")

# Outputs of this script -- OTU table without E minus only OTUs and phyloseq object with E- OTUs removed. No removal of singletons yet.

# End of Mareli's Code #
```

## Singleton removal
```{r, Singleton removal, tidy=TRUE}
# Filtering Taxa: Removal of singletons ####
 # Removal of  singletons
newpq1 <- filter_taxa(newpq, function (x) {sum(x > 0) > 1}, prune=TRUE)
# The result is 569 taxa in 156 samples.

# Relative abundance calculation ####
# Code below is for making the .csv file. After that refer to df rawra from .csv file.

# newpqRA <- transform_sample_counts(newpq1, function(x)x/sum(x))
# rabun <- subset(otu_table(newpqRA), rownames(otu_table(newpqRA)) %in% notShared)
# write.csv(rabun, "Aim3_OTU_Relative_Abundance_singletons_trimmed.csv")
#GPfr = filter_taxa(GPr, function(x) mean(x) > 1e-5, TRUE)


# Richness data frame ####
rich <- estimate_richness(newpq1, split = TRUE, measures = c("Observed","Shannon"))
rich
rich <- rich %>%
  rownames_to_column() %>%
  rename(Sample_name = rowname)

# Phyloseq object to data frames ####

# Cleaned: no singletons
newpqDF <- phyloseq_to_df(newpq1, addtax = T, addtot = F, addmaxrank = F, sorting = "abundance")
#write.csv(newpqDF, "Aim3_OTUs_assigned_nonsingletons.csv")

paged_table(head(newpqDF))
```

```{r, Loading phyloseq products, tidy = TRUE}

#These are the data frames resulting from the phyloseq data wrangling.

#The 569 OTUs and 156 samples (total abundances)
newpqDF <- read.csv("Aim3_OTUs_assigned_nonsingletons.csv")
newpqDF <- newpqDF %>%  # Code from the Taxonomical assginment section dopes the same. This is just calling it directly from the /csv to avoid running all the code. 
  select(!c(1))

# OTUs 959 and 156 samples (total abundances)

# eOTU <- read.csv("Aim3_OTU_phyloseq_trimmed.csv") 
# # Can upload as data frame. Use for distance matrices.
# 
# eOTU2 <- eOTU %>%
#   rename(OTU_ID = X) %>%
#   column_to_rownames(var = "OTU_ID") %>%
#   t() %>%
#   as.data.frame() %>%
#   rownames_to_column() %>%
#   rename(Sample_name = rowname)

# Saving
#saveRDS(eOTU2, file.path(save.path, "R_objects", "eOTU2.rds"))

# Reading
eOTU2 <- readRDS(file.path(save.path, "R_objects", "eOTU2.rds"))


# Just 569 OTUs and 156 samples (total abundances)
# cOTU <- newpqDF %>%
#   select(-kingdom, -phylum, -class, -order, -family, -genus, -species) %>%
#   column_to_rownames(var = "OTU") %>%
#   as.matrix() %>%
#   t() %>%
#   as.data.frame() %>%
#   rownames_to_column() %>%
#   rename(Sample_name = rowname)

# Saving
# saveRDS(cOTU, file.path(save.path, "R_objects", "clean_OTU.rds"))

# Reading
cOTU <- readRDS(file.path(save.path, "R_objects", "clean_OTU.rds"))

# Relative Abundance matrix (trimmed to 569 OTUs)
# rabun <- read.csv("Aim3_OTU_Relative_Abundance_singletons_trimmed.csv")
# rabun <- rabun %>%
#   rename(OTU_ID = X) %>%
#   column_to_rownames(var = "OTU_ID") %>%
#   na.omit() %>%
#   na.fail() %>%
#   as.matrix()

# Saving
# saveRDS(rabun, file.path(save.path, "R_objects", "rabun_tidy.rds"))

# Reading
rabun <- readRDS(file.path(save.path, "R_objects", "rabun_tidy.rds"))

# Relative Abundance matrix (singletons untrimmed Ascomycota 959 OTUs)
# rawra <- read.csv("Aim3_OTU_Relative_Abundance_singletons_untrimmed.csv")
# rawra <- rawra %>%
#   rename(OTU_ID = X) %>%
#   column_to_rownames(var = "OTU_ID") %>%
#   na.omit() %>%
#   na.fail() %>%
#   as.matrix()

# Saving
# saveRDS(rawra, file.path(save.path, "R_objects", "rawra_tidy.rds"))

# Reading
rawra <- readRDS(file.path(save.path, "R_objects", "rawra_tidy.rds"))

```

# Leaf functional traits: Correlations, autocorrelations, and network plots

In July 5, 2020 I attempted various ways to visualize and understand the correlations between covariates using autocorrelation functions, network correlations and Variance Inflation Factor (VIF) between independent variables (explanatory variables). 

```{r, Correlations and network, tidy = TRUE}
#Joining data frames
joined_newdata <- left_join(ndata2, ants, by = "Sample_name") #Possibly better to use full_join()
joined_newdata <-left_join(joined_newdata, patho, by = "Sample_name")

#Data frame for correlation network of explanatory variables ####
corr.data <- joined_newdata %>%
  ungroup() %>%
  select(Anthocyanins, Thickness, Toughness, LMA, Ant_percent_leafloss, Pathogen_percent_damage) 

#Unite Area loss and Damage area using mutate() and coalesce() These two are a measure of leaf damage either by pathogen or herbivore
corr.data <- corr.data %>%
  mutate(Area_damaged = coalesce(Ant_percent_leafloss, Pathogen_percent_damage)) %>%
  select(-Ant_percent_leafloss, -Pathogen_percent_damage) %>%
  na.omit()

# Looking for autocorrelations
c1 <- cor(ndata[,c(7:10)])
c1

# cor ####
#using cor() from 'stats'
cor.matrix <- as.data.frame(cor(ndata[c(7:10)]))
#Use 0.25 cut-off.
#Least correlated covariates are Toughness and Thickness: -0.124 

#Correlation matrix for correlation network using correlate() from 'corrr'

###All in one go to make correlation network plot following code from #https://www.datanovia.com/en/blog/easily-create-a-correlation-network-in-r-using-the-corrr-package/

wes_paleta <- wes_palette(name = "Darjeeling1", 3, type = "continuous")

network_traits <- corr.data %>% 
  correlate(use = "pairwise.complete.obs", method = "spearman", quiet = TRUE) %>%
  network_plot(rdf = .,
               min_cor = 0.0, 
               colors = c(wes_paleta), 
               curved = TRUE) +
  labs(title = "Correlation network of leaf traits" ) +
  theme(legend.text = element_text(size = 14))

network_traits
```

### VIF
```{r, tidy = TRUE}
#Variance Inflation Factor on simple LM with Toughness and Thickness

vif(lm(Abun_7 ~ Anthocyanins + Thickness + Toughness + LMA, data = ndata))

#
```

Variance inflation factors range from 1 upwards. The numerical value for VIF tells you (in decimal form) what percentage the variance (i.e. the standard error squared) is inflated for each coefficient. For example, a VIF of 1.9 tells you that the variance of a particular coefficient is 90% bigger than what you would expect if there was no multicollinearity — if there was no correlation with other predictors.
A rule of thumb for interpreting the variance inflation factor:
-1 = not correlated.
-Between 1 and 5 = moderately correlated.
-Greater than 5 = highly correlated.

```{r}
# Reference code
###Following code from https://drsimonj.svbtle.com/how-to-create-correlation-network-plots-with-corrr-and-ggraph

# cor.matrix3 <- corr.data %>%
#   correlate()%>%
#   stretch()
# 
# filter <- dplyr::filter
# 
# graph.cors <- cor.matrix3 %>%
# filter(abs(r) > .02) %>%
#  graph_from_data_frame(directed = TRUE)
# graph.cors
# 
# ggraph(graph.cors) +
#   geom_edge_link() +
#   # geom_node_point() +
#   geom_node_text(aes(label = name))

# ggraph(graph.cors) +
#   geom_edge_link(aes(edge_alpha = abs(r), edge_width = abs(r), color = r)) +
#   guides(edge_alpha = "none", edge_width = "none") +
#   scale_edge_colour_gradientn(limits = c(-1, 1), colors = c("firebrick2", "dodgerblue2")) +
#   geom_node_point(color = "grey", size = 5) +
#   geom_node_text(aes(label = name), repel = TRUE) +
#   theme_graph() +
#   labs(title = "Correlations between leaf traits")

#Following code from https://jamesmarquezportfolio.com/correlation_matrices_in_r.html

#chart.Correlation(cor.matrix3, histogram = TRUE, pch=19)

```

# Master data set: richness, diversity and abundances post-phyloseq

This data frame combines all the necessary richness, diverstiy and relative abundance estimates post-`phyloseq` manipulation with the data frames from the ant and pathogen assays. This is useful for testing hypothesis directly from one data set. 
```{r, Master data set, tidy = TRUE}
#This contains all the OTU id's per sample type. Hence, 156 (# samples) observations per OTU_ID. The phyloseq object achieves the same purpose. This data set is easier to use with other functions or test not supported by phyloseq.

# Master ####
#put all data frames into list
df_list_ant <- list(ndata2, cOTU, ants2, patho2, rich)    

#merge all data frames together
master <- df_list_ant %>% 
  reduce(left_join, by= "Sample_name", "E_load") %>%
 mutate(Total_reads = sum(across(starts_with("OTU")))) %>%
  group_by(Species) %>%
  mutate(Relative_Abundance = Total_reads/sum(Total_reads)) %>%
  select(c(1:9, 579:591)) %>%
   select(!c(E_load,
            E_load.y,
            Trial_Code,
            Trial_Code.y)) %>%
   relocate(Treatment, E_load.x, .after = Trial_type) %>%
  rename(Pathogen_Damage_area = Damage_area, 
         E_load = E_load.x, 
         Trial_Code = Trial_Code.x)

  # master_NAs <- master %>%
  # na.omit()

  
#Master with leaf traits
# put all data frames into list
# df_list <- list(ndata2, cOTU, ants3, patho3, rich)
# master2 <- df_list %>%
#   reduce(left_join, by= "Sample_name", "E_load") %>%
#  mutate(Total_reads = sum(across(starts_with("OTU")))) %>%
#   group_by(Species) %>%
#   mutate(Relative_Abundance = Total_reads/sum(Total_reads)) %>%
#    select(!c(E_load,
#             E_load.y,
#             Trial_Code,
#             Trial_Code.y)) %>%
#   relocate(c(579:590), .after = LMA)%>%
#    rename(Pathogen_Damage_area = Damage_area,
#          E_load = E_load.x,
#          Trial_Code = Trial_Code.x)
# write.csv(master2, "Aim3_master_data_04112023.csv")
# Glimpse
glimpse(master)
```

For `master` I remove empty rows just as I did in above section. Because I use `left_join()` with `ndata2` it returns empty cells for ant assay data but complete leaf trait measurements. 

## masterant
```{r, Ant Master Data, tidy = TRUE}
# Per plant
masterant <- master %>%
  subset(Trial_type == "Ant") %>%
  drop_na(Trial_Code) %>%
  select(!c(4, 13:14)) %>%
  na.omit()

# Glimpse
glimpse(masterant)


# Per Leaf
df_list_ant2 <- list(ndata, cOTU, ants2, patho2, rich)

masterant2 <- df_list_ant2 %>%
  reduce(left_join, by= "Sample_name", "E_load") %>%
 mutate(Total_reads = sum(across(starts_with("OTU")))) %>%
  group_by(Species) %>%
  mutate(Relative_Abundance = Total_reads/sum(Total_reads)) %>%
  select(c(1:10, 584:594)) %>%
  select(!c(E_load,
            Trial_Code)) %>%
  relocate(Treatment, E_load.x, .after = Trial_type) %>%
  rename(Pathogen_Damage_area = Damage_area, 
         E_load = E_load.x, 
         Trial_Code = Trial_Code.x) %>%
  subset(Trial_type == "Ant") %>%
  drop_na(Trial_Code) %>%
  select(!c(5, 14:15)) %>%
  na.omit() %>%
  mutate(logit_herbivory = logit(Ant_percent_leafloss))
# Glimpse
glimpse(masterant2)
```

For `masterant` I remove THEO T1 & T2 and APE28-29 just as I did in above section. I need to do this again because in creating the `master` data frame I join the data with `left_join()`. It results in rows with missing pathogen assay data and complete leaf trait data. There is no need for omiting NA's in `masterpat` because all the cells are complete.

## masterpat
```{r, Pathogen Master data, tidy = TRUE}
# Observations per plant level
masterpat <- master %>%
  subset(Trial_type == "Pathogen") %>%
  select(!c(11,12)) %>%
  na.omit()

# Glimpse
glimpse(masterpat)

# Observations per leaf level
# masterpat2

masterpat2 <- df_list_ant2 %>%
  reduce(left_join, by= "Sample_name", "E_load") %>%
 mutate(Total_reads = sum(across(starts_with("OTU")))) %>%
  group_by(Species) %>%
  mutate(Relative_Abundance = Total_reads/sum(Total_reads)) %>% 
  select(c(1:10, 584:594)) %>%
  select(!c(E_load,
            Trial_Code)) %>%
  relocate(Treatment, .after = Trial_type) %>%
  rename(Pathogen_Damage_area = Damage_area, 
         E_load = E_load.x, 
         Trial_Code = Trial_Code.x) %>%
  subset(Trial_type == "Pathogen") %>%
  select(!c(12:13)) %>%
  mutate(logit_pathogenicity = logit(Pathogen_percent_damage))


#mutate(Pathogen_percent_damage = pmin(pmax(Pathogen_percent_damage, 0), 1)) %>%  # Rescale values between 0 and 1
  #mutate(logit_damage = logit(Pathogen_percent_damage))
#masterpat2$log_damage <- log(masterpat2$Pathogen_percent_damage)
```


# Principal Component Analysis (PCA) of leaf functional traits

## Full PCA
```{r, PCA, tidy = FALSE}
# PCA using covariates to explain species richness/abundance ####
data.pca <- ndata[c(7,8,9,10)]
data.pca <- data.pca %>%
  rename(ACI = Anthocyanins, LT = Thickness, LPS = Toughness) #Renaming columns for plotting purposes.

###Run this to create pca with prcomp function
pca<-prcomp(data.pca, scale=TRUE)
pca$rotation=-pca$rotation
pca$x=-pca$x

#Checking the PCA
plot(pca,type = "lines")
biplot(pca) # Base type PCA

# PCA using autoplot() and prcomp()and modifying with ggplot syntax ####
auto <- autoplot((pca), data = data.frame(ndata), # For some reason this functions require data to be data= data.frame()
         alpha=0, #Setting alpha to zero render the automatic circle point null.Manipulate shapes with geom_point(). 
         loadings = TRUE,loadings.colour = "black",
         loadings.label=TRUE, loadings.label.colour="black",
         loadings.label.size= 4, size = 7, loadings.label.vjust = 0, 
         loadings.label.hjust = -0.3) + 
  geom_point(aes(fill = Species, color = Species, shape = E_load), alpha = 0.8, size = 3) +
  geom_hline(yintercept = 0, colour = "gray45") +
  geom_vline(xintercept = 0, colour = "gray45") +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  stat_ellipse(aes(color=Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1, level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
  theme_bw(base_size = 12) +
  labs(title = "Full PCA", caption = expression("ACI = anthocyanins, LPS = leaf punch strength, LMA = leaf mass per area, LT = leaf thickness. All leaf replicates per species ("~ italic("n") ~ "= 467).")) + 
  theme(plot.title = element_text(color="red", size = 14, face="bold.italic"))


auto$layers <- c(auto$layers, auto$layers[[2]], auto$layers[[3]]) # This adds/copies layers 2-3 and overlays them. It makes the arrows be on top of the points. There must be a better ways of doing this.

#Checking if all is good.
auto <- auto +
  theme(plot.caption = element_text(size = 6, hjust = 1, vjust = 1))
auto
#ggsave(filename="./Plots/Aim3_PCA_06052023.png", plot = auto, dpi=600, units=c("mm"), width = 180, height = 180, bg = "white")
```

```{r, PCA chatGPT, tidy=TRUE}
#Not great!

# ggplot PCA aided by ChatGPT following prompt "How can I plot the following by extracting the PCA scores and avoiding using the autoplot() function? "
##
# Plotting PCA scores
# scores <- as.data.frame(pca$x)
# scores$Species <- ndata$Species
# scores$E_load <- ndata$E_load
# 
# ggplot(scores, aes(PC1, PC2, fill = Species, color = Species, shape = E_load)) +
#   geom_point(alpha = 0.8, size = 3) +
#   geom_hline(yintercept = 0, colour = "gray45") +
#   geom_vline(xintercept = 0, colour = "gray45") +
#   scale_color_manual(values = met.brewer(name = "Cross", n = 8, type = "discrete")) +
#   stat_ellipse(aes(color = Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1, level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
#   labs(
#     x = "PC1",
#     y = "PC2",
#     caption = expression("ACI = anthocyanins, LPS = leaf punch strength, LMA = leaf mass per area, LT = leaf thickness. All leaf replicates per species (" ~ italic("n") ~ " = 467).")
#   ) +
#   theme_bw(base_size = 12)
# 
# # Plotting biplot
# loadings <- as.data.frame(pca$rotation)
# loadings$Variable <- rownames(pca$rotation)
# ggplot(loadings, aes(PC1, PC2, label = Variable)) +
#   geom_hline(yintercept = 0, colour = "gray45") +
#   geom_vline(xintercept = 0, colour = "gray45") +
#   geom_text(color = "black", size = 4, vjust = 0, hjust = -0.3) +
#   labs(x = "PC1", y = "PC2") +
#   theme_bw(base_size = 12)
```

## Ant PCA
```{r}
# PCA using covariates to explain species richness/abundance ####
ant_pcadata <- masterant2[c(7,8,9,10)]
ant_pcadata <- ant_pcadata %>%
  rename(ACI = Anthocyanins, LT = Thickness, LPS = Toughness) #Renaming columns for plotting purposes.


###Run this to create pca with prcomp function
ant.pca <-prcomp(ant_pcadata, scale=TRUE)
ant.pca$rotation=-ant.pca$rotation
ant.pca$x=-ant.pca$x

auto_ant <- autoplot((ant.pca), data = data.frame(masterant2), # For some reason this functions require data to be data= data.frame()
         alpha=0, #Setting alpha to zero render the automatic circle point null.Manipulate shapes with geom_point(). 
         loadings = TRUE,loadings.colour = "black",
         loadings.label=TRUE, loadings.label.colour="black",
         loadings.label.size= 4, size = 7, loadings.label.vjust = 0, 
         loadings.label.hjust = -0.3) + 
  geom_point(aes(fill = Species, color = Species, shape = E_load), alpha = 0.8, size = 3) +
  geom_hline(yintercept = 0, colour = "gray45") +
  geom_vline(xintercept = 0, colour = "gray45") +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  stat_ellipse(aes(color=Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1, level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
  theme_bw(base_size = 12) +
  labs(title = "Ant only PCA") +
  theme(plot.title = element_text(color="red", size = 14, face="bold.italic"))
# caption = expression("ACI = anthocyanins, LPS = leaf punch strength, LMA = leaf mass per area, LT = leaf thickness. All leaf replicates per species ("~ italic("n") ~ "= 210).")
  
  


auto_ant$layers <- c(auto_ant$layers, auto_ant$layers[[2]], auto_ant$layers[[3]]) # This adds/copies layers 2-3 and overlays them. It makes the arrows be on top of the points. There must be a better ways of doing this.

#Checking if all is good.
auto_ant <- auto_ant +
  theme(plot.caption = element_text(size = 6, hjust = 1, vjust = 1))
auto_ant

#ggsave(filename="./Plots/Aim3_Ant_PCA_07102023.png", plot = auto_ant, dpi=600, units=c("mm"), width = 180, height = 180, bg = "white")
```
## Pathogen PCA
```{r}
# PCA using covariates to explain species richness/abundance ####
pat_pcadata <- masterpat2[c(8,9,10,11)]
pat_pcadata <- pat_pcadata %>%
  rename(ACI = Anthocyanins, LT = Thickness, LPS = Toughness) #Renaming columns for plotting purposes.


###Run this to create pca with prcomp function
pat.pca <-prcomp(pat_pcadata, scale=TRUE)
pat.pca$rotation=-pat.pca$rotation
pat.pca$x=-pat.pca$x

auto_pat <- autoplot((pat.pca), data = data.frame(masterpat2), # For some reason this functions require data to be data= data.frame()
         alpha=0, #Setting alpha to zero render the automatic circle point null.Manipulate shapes with geom_point(). 
         loadings = TRUE,loadings.colour = "black",
         loadings.label=TRUE, loadings.label.colour="black",
         loadings.label.size= 4, size = 7, loadings.label.vjust = 0, 
         loadings.label.hjust = -0.3) + 
  geom_point(aes(fill = Species, color = Species, shape = E_load), alpha = 0.8, size = 3) +
  geom_hline(yintercept = 0, colour = "gray45") +
  geom_vline(xintercept = 0, colour = "gray45") +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  stat_ellipse(aes(color=Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1, level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
  theme_bw(base_size = 12) +
  labs(title = "Pathogen only PCA") +
  theme(plot.title = element_text(color="red", size = 14, face="bold.italic"))
# caption = expression("ACI = anthocyanins, LPS = leaf punch strength, LMA = leaf mass per area, LT = leaf thickness. All leaf replicates per species ("~ italic("n") ~ "= 210).")
  
  


auto_pat$layers <- c(auto_pat$layers, auto_pat$layers[[2]], auto_pat$layers[[3]]) # This adds/copies layers 2-3 and overlays them. It makes the arrows be on top of the points. There must be a better ways of doing this.

#Checking if all is good.
auto_pat <- auto_pat +
  theme(plot.caption = element_text(size = 6, hjust = 1, vjust = 1))
auto_pat

#ggsave(filename="./Plots/Aim3_Pathogen_PCA_08162023.png", plot = auto_pat, dpi=600, units=c("mm"), width = 180, height = 180, bg = "white")
```

# PCA: Simple linear models with PC1 and PC2

### Ants
```{r, Lm PCA data, tidy=TRUE}
# PCA loadings (rotations) data frame
ant.pci<-data.frame(ant.pca$x) #Species = ndata$Species not included.
glimpse(ant.pci)

# joined data frame for PC llinear regressions

ant_pcalm <- masterant2[c(1,2,5,12, 17)]

ant_pcalm <- cbind(ant_pcalm, ant.pci) #Both data sets have 467 observations
```
The functions `prcomp` and `princomp` are both possible to use for this analysis. The `prcomp` stores the "scores" as `x`, while `princomp` stores them as `scores`. Useful to know when extracting the data from it for linear regressions. The function `princomp` uses Eigen decomposition of the covariance and correlations between samples. The `prcomp` uses the singular value decomposition between variables.

#### Ants ~ PC1 & PC2
```{r, Ant PC1-2, tidy=TRUE}
# Formatting formula for p value
format.p <- function(p, precision = 0.001) {
  digits <- -log(precision, base = 10)
  p <- formatC(p, format = 'f', digits = digits)
  if (p < 0.001) {
    p = paste0('< ', precision)}
  if (p >= 0.001) {
    p = paste0('= ', p)    }
  sub("0", "", p)
}

lmpc1 <- lm(Ant_percent_leafloss ~ PC1, data = ant_pcalm)
summary(lmpc1)

# PC1
# Formatted p-value
p1 <- cor.test(ant_pcalm$Ant_percent_leafloss, ant_pcalm$PC1)$p.value

p1 = format.p(p1) # This is just to make the p-value nicer. 

## Plot PC1
       
ant_pc1 <- ggplot(ant_pcalm, aes(PC1, Ant_percent_leafloss)) +
  geom_jitter(aes(color = Species, shape = E_load), size = 3, alpha = 0.7) +
  geom_jitter(aes(color = Species), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  theme_minimal(base_size = 12) +
  labs(title = "Herbivory by leaf cutter ants vs. PC1", y = "Herbivory (%)", caption = "") +
  theme(plot.title = element_text(color="red", size = 14, face="bold.italic")) + 
    annotate(geom="text",label=sprintf("italic('p')~'%s'", p1),parse=TRUE,x=-2.5,y=65) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none")

ant_pc1

#ggsave(filename="./Plots/Aim3_AntPC1_07102023.png", plot = ant_pc1, dpi=600, units=c("mm"), width = 180, height = 180, bg = "white")


# PC2
# Formatted p-values
p2 <- cor.test(ant_pcalm$Ant_percent_leafloss, ant_pcalm$PC2)$p.value

p2 =format.p(p2) # This is just to make the p-value nicer. 

## Plot PC2
lmpc2 <- lm(Ant_percent_leafloss ~ PC2, data = ant_pcalm)
summary(lmpc2)

ant_pc2 <- ggplot(ant_pcalm, aes(PC2, Ant_percent_leafloss)) +
  geom_jitter(aes(color = Species, shape = E_load), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  theme_minimal(base_size = 12) +
  labs(title = "Herbivory by leaf cutter ants vs. PC2", y = "Herbivory (%)", caption = "") +
  theme(plot.title = element_text(color="red", size = 14, face="bold.italic")) +
 annotate(geom="text",label=sprintf("italic('p')~'%s'", p2),parse=TRUE,x=-1,y=65) +
    guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none")
  
  
ant_pc2

#ggsave(filename="./Plots/Aim3_AntPC2_07102023.png", plot = ant_pc2, dpi=600, units=c("mm"), width = 180, height = 180, bg = "white")
```

#### Ant Grid plot
```{r}
antpca_arranged <- ggarrange(auto_ant, ant_pc1, ant_pc2, nrow = 2, ncol=2, common.legend = TRUE, legend="right")

antpca_arranged
# Adding caption
ant_caption <- expression("*All individual leaves per individual per tree species included ("~ italic("n") ~ "= 210).")
ant_pca_with_caption <- annotate_figure(antpca_arranged, bottom = text_grob(ant_caption), fig.lab.pos = "bottom.right", fig.lab.size = 6)

ant_pca_with_caption

#ggsave(filename = "./Plots/Aim3_AntPCS_07102023.png", plot = ant_pca_with_caption, dpi=300, units=c("mm"), width = 300, height = 180, bg = "white")
```

### Pathogen
```{r, Lm PCA data, tidy=TRUE}
# PCA loadings (rotations) data frame
pat.pci<-data.frame(pat.pca$x) #Species = ndata$Species not included.
glimpse(pat.pci)

# joined data frame for PC llinear regressions

pat_pcalm <- masterpat2[c(1,2,5,6,13)]

pat_pcalm <- cbind(pat_pcalm, pat.pci) #Both data sets have 467 observations
```
The functions `prcomp` and `princomp` are both possible to use for this analysis. The `prcomp` stores the "scores" as `x`, while `princomp` stores them as `scores`. Useful to know when extracting the data from it for linear regressions. The function `princomp` uses Eigen decomposition of the covariance and correlations between samples. The `prcomp` uses the singular value decomposition between variables.

#### Pathogen ~ PC1 & PC2
```{r, Ant PC1-2, tidy=TRUE}
# Formatting formula for p value
format.p <- function(p, precision = 0.001) {
  digits <- -log(precision, base = 10)
  p <- formatC(p, format = 'f', digits = digits)
  if (p < 0.001) {
    p = paste0('< ', precision)}
  if (p >= 0.001) {
    p = paste0('= ', p)    }
  sub("0", "", p)
}

plmpc1 <- lm(Pathogen_percent_damage ~ PC1, data = pat_pcalm)
summary(plmpc1)

# PC1
# Formatted p-value
p1 <- cor.test(pat_pcalm$Pathogen_percent_damage, pat_pcalm$PC1)$p.value

p1 = format.p(p1) # This is just to make the p-value nicer. 

## Plot PC1
       
pat_pc1 <- ggplot(pat_pcalm, aes(PC1, Pathogen_percent_damage)) +
  geom_jitter(aes(color = Species, shape = E_load), size = 3, alpha = 0.7) +
  geom_jitter(aes(color = Species), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  theme_minimal(base_size = 12) +
  labs(title = "Pathogen damage vs. PC1", y = "Pathogen damage (%)", caption = "") +
  theme(plot.title = element_text(color="red", size = 14, face="bold.italic")) 
    #annotate(geom="text",label=sprintf("italic('p')~'%s'", p1),parse=TRUE,x=-2.5,y=5) +
  # guides(color = "none")  +      #To turn off color legend
  # guides(fill = "none") + #To turn off fill legend
  # guides(shape = "none")

pat_pc1

#ggsave(filename="./Plots/Aim3_AntPC1_07102023.png", plot = ant_pc1, dpi=600, units=c("mm"), width = 180, height = 180, bg = "white")


# PC2
# Formatted p-values
p2 <- cor.test(ant_pcalm$Ant_percent_leafloss, ant_pcalm$PC2)$p.value

p2 =format.p(p2) # This is just to make the p-value nicer. 

## Plot PC2
lmpc2 <- lm(Ant_percent_leafloss ~ PC2, data = ant_pcalm)
summary(lmpc2)

ant_pc2 <- ggplot(ant_pcalm, aes(PC2, Ant_percent_leafloss)) +
  geom_jitter(aes(color = Species, shape = E_load), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  theme_minimal(base_size = 12) +
  labs(title = "Herbivory by leaf cutter ants vs. PC2", y = "Herbivory (%)", caption = "") +
  theme(plot.title = element_text(color="red", size = 14, face="bold.italic")) +
 annotate(geom="text",label=sprintf("italic('p')~'%s'", p2),parse=TRUE,x=-1,y=15) +
    guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none")
  
  
ant_pc2

#ggsave(filename="./Plots/Aim3_AntPC2_07102023.png", plot = ant_pc2, dpi=600, units=c("mm"), width = 180, height = 180, bg = "white")
```

#### Pathogen Grid plot
```{r}
antpca_arranged <- ggarrange(auto_ant, ant_pc1, ant_pc2, nrow = 2, ncol=2, common.legend = TRUE, legend="right")

antpca_arranged
# Adding caption
ant_caption <- expression("*All individual leaves per individual per tree species included ("~ italic("n") ~ "= 210).")
ant_pca_with_caption <- annotate_figure(antpca_arranged, bottom = text_grob(ant_caption), fig.lab.pos = "bottom.right", fig.lab.size = 6)

ant_pca_with_caption

#ggsave(filename = "./Plots/Aim3_AntPCS_07102023.png", plot = ant_pca_with_caption, dpi=300, units=c("mm"), width = 300, height = 180, bg = "white")
```

# Phyloseq: 
## Statistical analyses and data visualization with Phyloseq

The `phyloseq` package allows me to perform most of the necessary analyses with just a couple of phyloseq objects (e.g. data frames, relative abundance calculations, etc.). Previous data frames created are still needed for further analyses (e.g. dbRDA and PSLR). There are some difficulties with manipulating the data with `phyloseq`. When merging objects the categorical facotrs are coerced to numeric, hence losing that information. See [here](https://github.com/joey711/phyloseq/issues/465) and comments in code chunks.

## Phyloseq: plots and graphs
```{r, Phyloseq plots and graphs, tidy = TRUE}
# # Abundance plots
# # Plots use data without singletons and trimmed for greenhouse endophytes.
# EndoAbun <- speedyseq::plot_bar(newpq1, "Species", "Abundance", "class") +
#   scale_fill_manual(values = met.brewer(name="Redon", n=11, type="continuous")) +
#   labs(title = "Ascomycota endophyte abundance(cleaned)" ) +
#   facet_wrap(~E_load)
# EndoAbun
# #ggsave(filename="Aim3_AbunBarPlot_06272022.jpeg", plot = EndoAbun, dpi=600, units=c("mm"), width=200, height=200)
# #
# # Agglomerate taxa and merging data to make plot ####
# # Similar to Relative abundance calculate in code above
# 
# #View(sample_data(newpq1))
# 
# #make a new phyloseq object that groups all taxa by class
# ps3 <- tax_glom(newpq1, "class") 
# #make it relative
# ps0 <- transform_sample_counts(ps3, function(x) x / sum(x))
# #merge samples so that they are all grouped/binned by species
# ps1 <- merge_samples(ps0, "Species")
# # repair factors
# sample_data(ps1)$Species <- levels(sample_data(ps0)$Species)[get_variable(ps1, "Species")]
# 
# #make relative again.
# ps4 <- transform_sample_counts(ps1, function(x) x / sum(x))
# 
# rel_abundplot <- plot_bar(ps4, "Species", "Abundance") + geom_bar(aes(fill=class), stat="identity", position="stack")+
#   labs(x = "Species", y = "Relative abundance (%)", fill="Class") +
#    scale_fill_manual(values = met.brewer(name = "Signac", type="discrete"))
# rel_abundplot
# 
# 
# ######
# 
# speedyseq::plot_bar(newpq1, "Species", "Abundance", "order") +
#   facet_grid(~E_load)
# 
# speedyseq::plot_bar(newpq1, "class", "Abundance", "class") +
# facet_grid(Species~.)
# 
# #plot_tree(taxglom, color = "Species", shape = "class", size = "abundance")
# 
# # Cladogram ####
# #plot_tree(newpq1, color="Species", label.tips="taxa_names", ladderize="left", plot.margin=0.3)
# 
# # Heatmap ####
# 
# #plot_heatmap(newpqRA, sample.label = "Species", taxa.label="class")
```

## Phyloseq: Richness
Plots with `phyloseq` package. 
```{r, tidy = TRUE}
# Richness ####
# Theme set
theme_set(theme_bw())
pal = "Set1"
scale_colour_discrete <-  function(palname=pal, ...){
  scale_colour_brewer(palette=palname, ...)
}
scale_fill_discrete <-  function(palname=pal, ...){
  scale_fill_brewer(palette=palname, ...)
}

# General plot with singletons

p <- plot_richness(newpq1, "Species", color = "Species",measures = c("Observed", "Shannon"), scales="free") +
  scale_color_manual(aes(color = "Species"),values = met.brewer(name="Redon", n=11, type="discrete")) +
  geom_point(size=2, alpha=0.7, position = "jitter") +
  geom_boxplot(alpha=0.7)+ 
  labs(title = "Ascomycota endophyte observed richness and Shannon Diversity" ) +
  theme(legend.position="none", axis.text.x=element_text(angle=45,hjust=1,vjust=1,size=12))
p$layers <- p$layers[-1]
p
#ggsave(filename = "Aim3_AlphaDiversity_06272022.jpeg", plot = p, dpi=600, units=c("mm"), width=200, height=200)


# Repair variables that were damaged during merge (coerced to numeric)
# See: https://github.com/joey711/phyloseq/issues/465
#Species
#replicates <- sample_data(mergedpq)$Species %>% 
 # sort()%>%
 # table()%>%
 # as.data.frame # you can use as_tibble(), but then you must use replicates$n in next line
#otu_table(mergedpq) <- otu_table(mergedpq)/replicates$Freq

#newmetdat <- sample_data(newpq) %>%
#  as_tibble() %>%
#  distinct(Species, .keep_all = TRUE) %>% 
 # arrange(Species) %>%
 # as.data.frame()
#rownames(newmetdat) <- rownames(otu_table(mergedpq))
#sample_data(mergedpq) <- newmetdat
```


## Phyloseq: Ordination and Distance matrices
The main purpose is to understand community similarity across trials and time points.This answers the general questions" 1) Did trials differ from each other? 2) Did time play a part in the community composition differences we see) -June/July 2023
```{r, tidy = TRUE}
# Just OTUs, without singletons
r <- ordinate(newpq1, "NMDS", "bray")

# NMDS by Trial_Code (Trial_Code = trial replicate)
p1 <- plot_ordination(newpq1, r, type = "samples", color = "Trial_Code", title = "Community Composition by Trial Code") +
  stat_ellipse(geom = "polygon", aes(fill = Trial_Code), alpha = 0.25, level = 0.95) +
 labs(caption = "Trials for ant and pathogen data sets go from T1-T5. Repeated surveys for ant data set are > T6") +
  facet_wrap(~Species)
p1 

#ggsave(filename ="./Plots/Aim3_NMDS_06022023_TrialCode.jpeg" , plot = p1, dpi=600, units=c("mm"), width=200, height=200)

# NMDS by Trial_type (an trial or pathogen trial)
p2 <- plot_ordination(newpq1, r, type = "samples", color = "Trial_type", title = "Community Composition by Trial type") +
  stat_ellipse(geom = "polygon", aes(fill = Trial_type), alpha = 0.25, level = 0.95) +
 labs(caption = "Commmunity composition for ant and pathogen data sets. For the most part, plants used for trials were inoculated at the same time per species and trialed and preserved within 5-6 days of final day of inoculation") +
  facet_wrap(~Species)
p2

#ggsave(filename ="./Plots/Aim3_NMDS_06022023_TrialType.jpeg" , plot = p2, dpi=600, units=c("mm"), width=200, height=200)

# # Samples 
p3 <- plot_ordination(newpq1, r, type="samples", color="Species")
p3 + geom_point(size = 3) +
  ggtitle("Tree Species")
  #facet_wrap(~E_load)
#geom_polygon(aes(fill=Species), alpha = 0.5) +
p3

# # biplot
# p3 = plot_ordination(newpq, r, type="biplot", color="class", shape="class", title="biplot")
# p3
# 
# # Split
# p4 = plot_ordination(newpq, r, type="split", color="class", title="split", label="Species") 
# p4
```

After meddling with this for a little bit, I do not like how this plots my data. I find it confusing to edit and know what it is plotting exactly. I will plot these ordinations by using the data frames cleaned and trimmed with phyloseq. -BAR 06/19/2022
*The  main ordination plot is the one produces in the dbRDA section. These ordination are good for supplementary material information* -BAR 7/04/2023



# Leaf traits and relative abundance and total reads of OTUs
```{r, tidy = FALSE}
# Endophyte growth proportion at day 7 grouped by endophyte load and species with data (data) ####

mycomparisons <- list(c("APEIME", "DYPTE", "CORDAL", "THEOCA","LACPA", "HEISCO", "CHRYCA")) 
              #map_signif_level=TRUE)
# mycomparisons <- list(c(master$Species))
ecomparisons <- list(c(master$E_load))
#Total reads
ggplot(data = master, aes(x = E_load, y = Total_reads), group_by(Species)) +
  geom_boxplot(aes(fill = E_load), outlier.shape = NA)+
  theme_bw(base_size = 16) + 
  labs(x="", y="Total_reads")+
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 24),
        axis.text.x=element_blank()) +
  annotate("text", x = 2.5, y = .65, label = "")+
  ylim(0,75000) +
  facet_wrap(~Species)
 
# Antocyanins by endophyte load and species with data (data) ####
# RA boxplots

RA <- ggplot(data= master, aes(x = Species, y = Relative_Abundance)) +
  geom_boxplot(aes(fill = E_load), outlier.shape = NA) +
  geom_crossbar(stat="summary", fun = mean, fun.max = mean, fun.min = mean,  fatten = 2, width = 0.5) +
  geom_point(color="black", alpha = 0.2,size =2, position = position_jitter(w=0.05)) +
  scale_fill_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  theme_bw(base_size = 16) + 
  theme(panel.grid.major = element_line(colour = "grey")) +
  theme(panel.grid.minor = element_line(colour = "grey")) +
  theme(strip.background = element_rect(fill = "white")) +
  theme(strip.text.x = element_text(colour = "black", face = "bold")) +
  theme(legend.title = element_text(face = "bold")) +
  theme(panel.border = element_rect(linetype = "blank", fill = NA)) +
  labs(y="Relative Abundance of OTUs (Ascomycota)")+
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 24),
        axis.text.x=element_text(angle = 30)) +
  labs(caption = "*Outliers and singletons removed.") +
  scale_x_discrete(labels= mycomparisons) +
  #annotate("text", x = 2.5, y = .65, label = "") +
  stat_compare_means(comparisons = mycomparisons ) +
  stat_compare_means(comparisons = ecomparisons) +
  stat_compare_means(method = "kruskal.test", label = "p.signif") 
  #ylim(0, 0.13) +
  #facet_wrap(~E_load)
RA
#ggsave(filename="Aim3_RA_Species_0706202.png", plot = RA, dpi=600, units=c("mm"), width = 300, height = 300)


# RA per E_load
RAE <- ggplot(data= master, aes(x = E_load, y = Relative_Abundance)) +
  geom_violin(aes(fill = E_load), outlier.shape = NA) +
  geom_crossbar(stat="summary", fun = mean, fun.max = mean, fun.min = mean,  fatten = 2, width = 0.5) +
  geom_point(color="black", alpha = 0.2,size =2, position = position_jitter(w=0.05)) +
  scale_fill_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  theme_bw(base_size = 16)+
  
  theme(panel.grid.major = element_line(colour = "grey")) +
  theme(panel.grid.minor = element_line(colour = "grey")) +
  theme(strip.background = element_rect(fill = "white")) +
  theme(strip.text.x = element_text(colour = "black", face = "bold")) +
  theme(legend.title = element_text(face = "bold")) +
  theme(panel.border = element_rect(linetype = "blank", fill = NA)) +
  labs(x="", y="Relative Abundance of OTUs (Ascomycota)", face = "bold")+
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 24),
        axis.text.x=element_blank()) +
  labs(caption = "*Outliers and singletons removed.") +
  geom_signif(comparisons = list(c("E-", "E+")), 
              map_signif_level=TRUE)

RAE
#ggsave(filename="Aim3_RA_Eload_07062022.png", plot = RAE, dpi=600, units=c("mm"), width = 300, height = 300)


# Leaf thickness by endophyte load and species

LT <- ggplot(data = master, aes(x = Species, y = Thickness), color = Species) +
  geom_violin(aes(fill = E_load),outlier.shape = NA) +
  geom_crossbar(stat="summary", fun = mean, fun.max = mean, fun.min = mean,  fatten = 2, width = 0.5) +
  geom_point(color="black", alpha = 0.2,size =2, position = position_jitter(w=0.05)) +
  scale_fill_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  theme_bw(base_size = 18) +
  theme(panel.grid.major = element_line(colour = "grey")) +
  theme(panel.grid.minor = element_line(colour = "grey")) +
  theme(strip.background = element_rect(fill = "white")) +
  theme(strip.text.x = element_text(colour = "black", face = "bold")) +
  theme(legend.title = element_text(face = "bold")) +
  theme(panel.border = element_rect(linetype = "blank", fill = NA)) +
  labs(x="", y= expression(paste("Leaf thickness (",mu,"m)"))) +
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 24)) +
  labs(caption = "*Outliers and singletons removed.") +
  annotate("text", x = 2.5, y = .65, label = "") +
  #stat_compare_means(comparisons = mycomparisons) +
 # stat_compare_means(method = "kruskal.test", label = "p.signif") +
  stat_compare_means(label = "p.signif", method = "t.test",
                     ref.group = ".all.", label.y = 300) +
  ylim(100,325)
LT
#ggsave(filename="Aim3_LT_Species_07062022.png", plot = LT, dpi=600, units=c("mm"), width = 300, height = 300)


# Leaf toughness (lbf) by  endophyte load and species with data (data) ####
ggplot(data = master, aes( x = Species, y = Toughness), group_by(Species)) +
  geom_violin(aes(fill = E_load), outlier.shape = NA) +
  geom_crossbar(stat="summary", fun = mean, fun.max = mean, fun.min = mean,  fatten = 2, width = 1) +
  geom_point(color="black", alpha = 0.2,size =2, position = position_jitter(w=0.05)) +
  scale_fill_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  theme_bw(base_size = 16) +
  theme(panel.grid.major = element_line(colour = "grey")) +
  theme(panel.grid.minor = element_line(colour = "grey")) +
  theme(strip.background = element_rect(fill = "white")) +
  theme(strip.text.x = element_text(colour = "black", face = "bold")) +
  theme(legend.title = element_text(face = "bold")) +
  theme(panel.border = element_rect(linetype = "blank", fill = NA)) +
  labs(x="", y= expression(paste("Leaf punch strength(N mm","^-1)"))) +
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 24)) +
  labs(caption = "*Outliers and singletons removed.") 
 # stat_compare_means(comparisons = mycomparisons ) +
  #stat_compare_means(method = "kruskal.test", label = "p.signif") +
  #ylim(0.10, 1) 

# Leaf mass per area (LMA) by  endophyte load and species
ggplot(data = master, aes(x = E_load, y = LMA), group_by(Species)) +
  geom_boxplot(aes(fill = E_load)) +
  theme_bw(base_size = 18) + 
  labs(x="", y="LMA (mg)")+
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(face = "italic", size = 18),
        axis.text.x=element_blank()) +
  annotate("text", x = 2.5, y = 0.0024, label = "")+
   scale_y_continuous(limits=c(0.0001,0.0025)) +
  stat_compare_means(comparisons = mycomparisons ) +
  stat_compare_means(method = "kruskal.test", label = "p.signif") +
  facet_wrap(~Species)

# Diversity
DVI <- ggplot(data= master, aes(x = E_load, y = Shannon)) +
  geom_violin(aes(fill = E_load), outlier.shape = NA) +
  geom_crossbar(stat="summary", fun = mean, fun.max = mean, fun.min = mean,  fatten = 2, width = 0.5) +
  geom_point(color="black", alpha = 0.2,size =2, position = position_jitter(w=0.05)) +
  scale_fill_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  scale_color_manual(values= met.brewer("Cross", n = 2, type = "discrete")) +
  theme_bw(base_size = 16) + 
  theme(panel.grid.major = element_line(colour = "grey")) +
  theme(panel.grid.minor = element_line(colour = "grey")) +
  theme(strip.background = element_rect(fill = "white")) +
  theme(strip.text.x = element_text(colour = "black", face = "bold")) +
  theme(legend.title = element_text(face = "bold")) +
  theme(panel.border = element_rect(linetype = "blank", fill = NA)) +
  labs(x="", y="Shannon Diversity Index of OTUs (Ascomycota)")+
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 24),
        axis.text.x=element_blank()) +
  labs(caption = "*Outliers and singletons removed.") +
  annotate("text", x = 2.5, y = .65, label = "") +
  stat_compare_means(comparisons = mycomparisons ) +
  stat_compare_means(method = "kruskal.test", label = "p.signif") +
  facet_wrap(~Species)
DVI
#ggsave(filename="Aim3_DV_Eload_07122022.png", plot = DVI, dpi=600, units=c("mm"), width = 300, height = 300)


####I HAVE TO INVESTIGATE FURTHER AS TO WHY THIS LAST GGPLOT FOR LMA GIVE THIS OUTPUT: Warning messages:1: Removed 34 rows containing non-finite values (stat_boxplot). 2: Removed 7 rows containing missing values (geom_text).
####
####This problem was due to having values out of the ylab.
```

# FEF Community Analysis

## Distance-based redundancy analyses (dbRDA)
### dbRDA and partial dbrda

Code written by Mareli Sánchez Juliá. Modified by Bolívar Aponte Rolón- March 2022 Partial dbRDA was eliminated. Due to my experimental set up, performing a partial dbRDA does not make much sense. This is useful when looking at change over time in a categorical manner (e.g. sampling every two weeks). My data set does not test for anything similar.

An explanation of why we use dbRDA with oout type of data from Perter Tellez's 2022 paper: *"We used distance-based redundancy analyses (dbRDA) to visualize associations between leaf functional traits and endophyte communities. We excluded OTUs represented by a single sequence (singletons) and calculated a Bray-Curtis dissimilarity matrix based on endophyte relative abundance data".*
*We tested for differences in endophyte community composition as a function of host species and genus, using a permutational multivariate analysis of variance (PERMANOVA, 999 permutations, (69)). We used a permutational analysis of multivariate dispersion (PERMDISP; (69)) to test for homogeneity of variance in endophyte communities. We used a PERMDISP as a companion to PERMANOVA to exclude the possibility that any significant differences were caused by differences in the variance of endophyte communities. The relative explanatory power of host species and leaf functional traits on endophyte communities was compared using a partial-dbRDA.*

Results from dbRDA (`capscale`) have not been compared to PERMANOVA (`adonis2`) yet. - 11/21/22. Results should be the same or very similar.

### Making a distance matrix
```{r, Distance Matrix}
otu_e.dist <- vegdist(t(rabun), method="bray", binary=FALSE)
#Using "rabun". No singletons
#Bray-Curtis dissimilarity matrix
```


## Hill numbers, INEXT and the new diversity world order

```{r}


```

## Leaf trait selection

### Choosing traits for dbRDA model
```{r}
# Model with intercept only ####
m0 <- capscale(otu_e.dist ~ 1, data = ndata2, na.action = na.omit) #Model with intercept only.
m0
m1 <- capscale(otu_e.dist ~ ., data = ndata2, na.action = na.omit) # Model with all explanatory variables.
m1

# Model with species, eload and leaf traits. ####
m2 <- capscale(otu_e.dist ~ Species + E_load + Anthocyanins + Thickness + Toughness + LMA, data = ndata2, na.action = na.omit)
m2

# Model with just traits ####
# No species, Trial_type and E_load
m3 <- capscale(otu_e.dist ~ Anthocyanins + Thickness + Toughness + LMA, data = ndata2, na.action = na.omit)
m3
Anova(m3)
```

### Forward and backward selection with ordistep - just leaf traits

```{r}
#Both, forward and backward selection. This way I can see the step by step.
#m3
m2.forsel <- ordistep(m0, scope = formula(m2), Pin = 0.5, Pout =.1 ,trace = T, pstep = 1000, direction = "forward")
#m2.forsel$anova # I used m2 as the "scope" because it does not contain Trial_type. This is a factor that is only relevant for the ant an pathogen trial. Differences detected between the trial types not important or unrealistic for the question at hand. 

#summary(m2.forsel)
#m2.forsel$anova
#anova(m2.forsel, by = "margin") # test for sign. environ. variables 
#anova(m2.forsel, by = "axis") # test axes for significance
#anova(m2.forsel, by="axis", perm.max=500) #tests for sign. variables, but adds them sequentially.

#m3 taking E_load out. Again not relevant. What I want to know is the influence the leaf traits have on the fungal community. 
m3.forsel <- ordistep(m0, scope = formula(m3), Pin = 0.5, Pout = 0.1, trace = T, pstep = 1000, direction = "forward")
#m3.forsel$terms
#summary(m3.forsel)

#anova(m3.forsel, by = "margin") 
#anova(m3.forsel, by = "axis")
#anova(m3.forsel, by="axis", perm.max=500) 

## Model 3 and 5 keep species and trial type as the most significant explanatory variables. Yes, the community composition will be different across spcies but this is due to the inherent leaf traits of each species. Not "species" itself. 
```


### dbRDA Results

#### Plotting m3 model dbRDA

```{r, m3 dbRDA, tidy = TRUE}
#m3.forsel 
# Terms: otu_e.dist ~ Thickness + Toughness + Anthocyanins + LMA
m3dbRDA <- capscale(otu_e.dist ~ Anthocyanins + Toughness + Thickness + LMA, data= ndata2, dist="bray", na.action = na.omit)
summary(m3dbRDA)
plot(m3dbRDA)

#GRAPHING dbRDA - m4.forsel -- with color by continous leaf lifespan
#plot using ggplot2
names(m3dbRDA)
B <- summary(m3dbRDA)

A.1 <- vegan::scores(m3dbRDA)
A.2 <- A.1$sites
A.3 <- cbind(A.2, ndata2)

#scores for arrows
A.4 <- data.frame(vegan::scores(m3dbRDA, display = "bp"))
A.4

# Define the arrow aesthetic mapping
arrow_map <- aes(xend = (CAP1*2), yend = (CAP2*2), x = 0, y = 0, shape = NULL, color = NULL, fill = NULL)
label_map <- aes(x = 2*CAP1, y = 2*CAP2, label = row.names(A.4), shape = NULL, color = NULL, fill = NULL)
arrowhead = arrow(length = unit(0.02, "npc"))

#subset A4 for labeling
A.4 <- A.4[sort(rownames(A.4)),]
A.4
A4.sub1 <- A.4[3,] #Thickness
A4.sub2 <- A.4[1,] #Anthocyanins
A4.sub3 <- A.4[2,] #LMA
A4.sub4 <- A.4[4,] #Toughness

A.4
#A4.sub4

# Make plot
p_m3 <- ggplot(data = A.3, aes(x = CAP1, y = CAP2))
p_m3
p_m3dbrda <- p_m3 +
  geom_point(data = A.3, aes(color = Species), size = rel(3), alpha = 0.8, stroke = 1) +
  geom_segment(arrow_map, size = rel(.8), data = A.4, color = "black", arrow = arrowhead) +
  geom_vline(xintercept = 0, color = "grey30", linetype = "dashed") + # plot vertical line
  geom_hline(yintercept = 0, color = "grey30", linetype = "dashed") + # plot horizontal line
  geom_text(label_map, size = rel(4), data = A4.sub1, fontface = "bold", show.legend = FALSE, hjust = 1, label = c("LT"), nudge_y = -0.15) +
  geom_text(label_map, size = rel(4), data = A4.sub2, fontface = "bold", show.legend = FALSE, hjust = -0.1, label = c("ACI"), nudge_y = 0.2) +
  geom_text(label_map, size = rel(4), data = A4.sub3, fontface = "bold", show.legend = FALSE, hjust = 0.8, label = c("LMA"), nudge_y = -0.2) +
  geom_text(label_map, size = rel(4), data = A4.sub4, fontface = "bold", show.legend = FALSE, hjust = 0.9, label = c("LPS"), nudge_y = -0.17) +
  xlab(label = paste("CAP1 (", round(B$concont$importance[2,1]*100, digits = 1), "%)", sep="")) +
  ylab(label = paste("CAP2 (", round(B$concont$importance[2,2]*100, digits = 1), "%)", sep="")) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  stat_ellipse(aes(color=Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1,
               level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
  labs(caption = "ACI = anthocyanins, LPS = leaf punch strength, LMA = leaf mass per area, LT = leaf thickness")+
     theme_bw(base_size = 16)
# Rearranging the order of layers so arrows are above the points.
p_m3dbrda$layers
p_m3dbrda$layers <- c(p_m3dbrda$layers, p_m3dbrda$layers[[2]], p_m3dbrda$layers[[5]], p_m3dbrda$layers[[6]], p_m3dbrda$layers[[7]], p_m3dbrda$layers[[8]])
p_m3dbrda

MetBrewer::colorblind_palettes
MetBrewer::colorblind.friendly("Cross")
#ggsave(filename="Aim3_m3dbRDA_07062022.svg", plot=p_m3dbrda, dpi=600, units=c("mm"), width=300, height=300)
```



## NMDS: Non-Metric Multidimensional Scaling

A brief explanation on the use of NMDS to interpret our projects: *We used LMA, LDMC, leaf punch strength, leaf thickness, %C, and %N as the constraining variables. Next, we used PERMANOVA marginal tests to assess the amount of variation explained by each leaf trait. We used Non-metric Multidimensional Scaling (NMDS) to visualize patterns in endophyte communities among host taxa.* -Peter tellez (2022)
```{r, NMDS, tidy = TRUE}
#Ordination - NMDS with bray-curtis #########
x <- as.matrix(otu_e.dist)

# Choosing the number of dimensions
NMDS.scree <- function(x) { #where x is the name of the data frame variable
  plot(rep(1, 10), replicate(10, metaMDS(x, autotransform = F, k = 1)$stress), xlim = c(1, 10),ylim = c(0, 0.30), xlab = "# of Dimensions", ylab = "Stress", main = "NMDS stress plot")
  for (i in 1:10) {
    points(rep(i + 1,10),replicate(10, metaMDS(x, autotransform = F, k = i + 1)$stress))
  }
}

#NMDS.scree(x) #4 dimension seem to be appropriate to keep the stress around 0.15. More dimension will complicate the interpretation of results.

NMDS <- metaMDS(x,
                distance = "bray",
                display = c("sites", "species"),
                noshare = TRUE,
                autotransform = FALSE,
                wascores = TRUE,
                tidy = TRUE,
                k = 4,trymax = 500)
stressplot(NMDS)
##NMDS does not have the "species" or "site" scores for some reason. This worked up until Oct 6, 2022.

#Adding site scores to `NMDS`
sppscores(NMDS) <- t(rabun) # `rabun` if the dataframe with raw relative abundance of OTU's. It does not contain Ascomycota singletons (total = 569 OTUs).

data.scores <- as_tibble(vegan::scores(NMDS)$sites)#Using the scores function from vegan to extract the site scores and convert to df for ggplot use.
# Solution found here: https://stackoverflow.com/questions/71941069/species-scores-not-available-as-result-of-metamds

# NMDS Aesthetics ####

NM.DS <- ggplot(data.scores, aes(NMDS1, NMDS2, color = ndata2$Species)) +
  geom_point(data = data.scores, aes(shape= ndata2$Trial_type),size = 3, alpha = 0.5, stroke = 1) +
  scale_shape_manual(values=c(15:22)) +
  # scale_color_manual(values = met.brewer(name = "Nizami", n = 8, type="discrete")) +
  geom_hline(yintercept = 0, colour = "grey50", size = 0.65) +
  geom_vline(xintercept = 0, colour = "grey50", size = 0.65) +
  theme_bw(base_size = 12) +
  theme(legend.position="right", legend.title = element_text(),
        legend.text = element_text(face = "italic")) +
  stat_ellipse(mapping = NULL, data = data.scores, geom = "path", size = 1.3,
position = "identity", type = "t", linetype = 1, level = 0.95, segments = 51,
na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) 

NM.DS
#ggsave(filename ="Aim3_NMDS_06272022.jpeg" , plot = NM.DS, dpi=600, units=c("mm"), width=200, height=200)
#
#
```


## ANOSIM
```{r}
# ANOSIM ####
# Tests if differences between groups are greater than within groups. 
otu.anosim <- anosim(otu_e.dist, ndata2$Species, permutations = 999, distance = "bray", strata = NULL)
summary(otu.anosim)
plot(otu.anosim) 
```

# PLSR: Partial Least Squares Regression

Results not included. Analysis is not complete -11/21/2022

```{r, include = FALSE}
# # Manipulating the data for PLSR
# master22 <- master2 %>% 
#    rowwise() %>%
# #mutate(ReAbun = list(x/sum(across(starts_with("OTU")),
#  # na.rm = T))
# 
# estimate_richness(newpq, measures = c("Observed", "Shannon"))
# 
# plr <- plsr(otu_e.dist_T ~ Anthocyanins + Toughness +Thickness + LMA, data= ndata2, validation = "CV", na.action = na.omit)
```


# Raw Leaf Trait Analyses

### Leaf-cutter ants analyses

The idea here is to see which leaf functional trait and community diversity traits (relative abundance, richness and diversity) impact herbivory and pathogenicity.
Only using LMA, thickness and toughness, as these covariates are orthagonal to each other in PCA analysis.

### Descriptive statistics

**Preliminary analyses as of 08/26/2019** These preliminary analyses were performed before the Ecological Analyses course. Not everything is useful. Certainly the GGPLOT MAGIC section is the exception. Those plots are an essential part of the story. 

Evaluating non-normality of the data do not use `master` data set to assess the assumption of normality. It includes duplicate information for the explanatory variables. Meaning a sample and its data are paired multiples times with the OTU's that are present in it. Use either `data` or `ndata`.

Proceeding with exploring normality assumptions with `data` and `masterant`. It retains the mean values for all leaf replicates.

From this autocorrelation matrix I can see that the Observed richness, Shannon diversity and Total_reads have low autocorrelation the physical leaf functional traits. These three measures of community composition are somewhat correlated. Especially the Observed species richness and the Shannon diversity index (0.719735754) and Total_reads x Shannon(-0.3244523). For this reason I am going to stick to using Shannon diversity are a community traits for predicting leaf herbivory and pathogenicity. LMA is highly collinear with Anthocyanins and Toughness, while it has very low correlation with Ant_percent_leafloss. I will not include ANthocyanins in the linear models. Thickness and toughness are inversely correlated with each other. Toughness seems to have a low negative correlation with *Ant_percent_leafloss*, or *Total_leaf_area_cut*. I will not include it in the linear models.

```{r}
# Data
# Histograms ####
# Explanatory variables
hist(data$Anthocyanins)
hist(data$Thickness..micro.m.,
     xlim = c(0,500))
hist(data$Toughness)
hist(data$LMA)


# QQnorms ####
#qqnorm(rnorm(n = length(data$Anthocyanins..aci.), 
             #mean =mean(data$Anthocyanins..aci., na.rm = TRUE), 
             #sd = sd(data$Anthocyanins..aci., na.rm = TRUE)))

# QQPlots ####
#qqPlot(rnorm(n = length(data$Anthocyanins..aci.), 
             #mean =mean(data$Anthocyanins..aci., na.rm = TRUE), 
             #sd = sd(data$Anthocyanins..aci., na.rm = TRUE)))
             
#Using "data" set
qqPlot(data$Anthocyanins..aci.)
qqPlot(data$Thickness..micro.m.)
qqPlot(data$Toughness..lbf.)
qqPlot(data$LMA_dw)


masterant$Prop_area_loss <- masterant$Ant_percent_leafloss/100

qqPlot(masterant$Prop_area_loss)

#Using "masterant2"

qqPlot(masterant2$Ant_percent_leafloss)
qqPlot(masterant2$Anthocyanins)
qqPlot(masterant2$Thickness)
qqPlot(masterant2$Toughness)
qqPlot(masterant2$LMA)
qqPlot(masterant2$Shannon)

#Nothing has a normal distribution. It looks like it will be necessary to use a negative binomial distribution. 

# Shapiro-Wilks tests ####
#shapiro.test(rnorm(n = length(data$Anthocyanins..aci.), 
                   #mean =mean(data$Anthocyanins..aci., na.rm = TRUE), 
                   #sd = sd(data$Anthocyanins..aci., na.rm = TRUE)))
                   #shapiro.test(masterant$Prop_area_loss)
                   

hist(masterant$Ant_percent_leafloss) #Binomial 
shapiro.test(masterant$Ant_percent_leafloss) #Data deviates from the normal distribution. p-values is 0.0002607
shapiro.test(masterant$Anthocyanins) #Borderline non-normal p-value = 0.05605

shapiro.test(masterant$Thickness) #Non-normal p-value = 0.07201
shapiro.test(masterant$Toughness) #Non-normal p-value = 0.0005036
hist(masterant$Toughness)
shapiro.test(masterant$LMA) #normal p-value = 0.4742
shapiro.test(masterant$Shannon) #Normal p-value = 0.4886
hist(masterant$Shannon)



# Somewhat better distributions.

# Ant_percent_leafloss is not normally distributed. It looks more like a binomial distribution. Evaluate accordingly. 

#Conclusion from the Shapiro-Wilk tests. Some of the independent variables are not normally distributed. 

# Re-eveluating autocorrelation of terms ####

# Variance Inflation Factor on simple LM with Toughness and Thickness

vif(lm(Ant_percent_leafloss ~ Anthocyanins + Thickness + Toughness + LMA + Observed + Shannon + Total_reads, data = masterant))
#Variance inflation factors range from 1 upwards. The numerical value for VIF tells you (in decimal form) what percentage the variance (i.e. the standard error squared) is inflated for each coefficient. For example, a VIF of 1.9 tells you that the variance of a particular coefficient is 90% bigger than what you would expect if there was no multicollinearity — if there was no correlation with other predictors.
#A rule of thumb for interpreting the variance inflation factor:

#1 = not correlated.
#Between 1 and 5 = moderately correlated.
#Greater than 5 = highly correlated.

# All explanatory variables have a VIF that is moderately correlated.
# cor()
corr <- cor(masterant[,c(6:13)])
corr
corrplot::corrplot(corr, type="upper", order="hclust")

#To compute the matrix of p-value, a custom R function is used :

# mat : is a matrix of data
# ... : further arguments to pass to the native R cor.test function
cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j], ...)
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}
# matrix of the p-value of the correlation
p.mat <- cor.mtest(corr)
head(p.mat[, 1:8])

corrplot::corrplot(corr, method = "color", type = "upper", order = "hclust",addCoef.col = "black", # Add coefficient of correlation
         tl.col="black", tl.srt=45, #Text label color and rotation
         # Combine with significance
         p.mat = p.mat, sig.level = 0.05, 
         # hide correlation coefficient on the principal diagonal
         diag=FALSE
         )

```

### Paired T-tests: Ant Herbivory

Paired is not the same as pairwise.
Pairwise refers to the comparison each group compared with every other group.

```{r, Total leaf area cut, tidy = TRUE}
t.test(formula = Total_leaf_area_cut ~ E_load,
  alternative = "two.sided",
       mu = 0, 
       paired = T,   
       var.equal = TRUE,
       na.rm = FALSE,
       conf.level = 0.95, data = masterant)
 plot(Total_leaf_area_cut ~ E_load, data = masterant)
ant_paired <- ggplot(masterant, aes(E_load, Total_leaf_area_cut)) +
  geom_boxplot(aes(fill = Species))
ant_paired

#ggsave(filename = "ant_paired.png", plot = ant_paired, dpi=600, units=c("mm"), width=300, height=300)
```

# How do leaf traits influence herbivory and pathogenicity?

## Ant Linear Mixed Models: raw functional leaf traits
Now that we have answered how the leaf functional traits influence influence the effects of herbivory and pathogenicity in plants. In June 2023, we have eliminated "Shannon Diversity" as a fixed effects. We will evaluate the effects of community diversity and composition in other analyses.

```{r, Ant Linear Mixed Models wit masterant2 data set, tidy = TRUE}

### ANTS:Diversity

#M1 no interactions
#Ant_percent_leafloss ~ Anthocyanins + Thickness + Toughness + LMA +E_load+ Shannon + Observed + Total_reads

#B1 <- glm(Prop_area_loss ~ Anthocyanins + Thickness +Toughness + LMA + Shannon + (1+ Species), family = gaussian(link = "identity"), data = masterant, na.action = na.exclude)

#plot_model(B1, type = "diag")
#plot_model(B1)
#Anova(B1, type = 3)

# Model with intercept only ####
M0 <- lm(logit_herbivory ~ 1, data = masterant2, na.action = na.exclude)
plot(M0)


# M1 ####

M1 <- lm(logit_herbivory ~ LMA + Species + Anthocyanins + Thickness + Toughness + E_load, data = masterant2, na.action = na.exclude)

#Model with all continuous explanatory variables.

summary(M1)
AIC(M1) # 647.3 # 1906.002 as of 5/23/23
# Transforming "Ant_percent_leafloss" with logit() and using that transformed data reduces the AIC value to ~738. It is a better fit model. The transformation of percent herbivory is due to the many values close to zero or zeros. 

# Residuals
M1_resid <- resid(M1, type = "response")
M1_fitted <- fitted(M1)

#Histograms
hist(M1_resid)
hist(M1_fitted)

# Plots
plot(M1)
plot_model(M1, type = "diag")

# Using "masterant2" improves normality of residuals and overall model. 5/23/2023
# Species has a high VIF. This should change when I use species as a random effect.

#The residuals spread increases slightly as the fitted values increase. Indicating heterogeneity.
#
##  Note that some nests have residuals that are above or below the zero line, indicating the need for a random effect. Possibly Species and E_Load

# Three ways to get type 3 anova. The first one requires that there are no atomic vector. The ;linear regression has to be coded in one line, not creating shorthand formula. The rest are pretty self evident. For drop1(model,.~., test = "F) we obtain the same as Anova() from the "car" package. Without the .~. we obtain terms or interactions that are not significant. 

#anova(M1,type="marginal") #What is a type III ANOVA?
Anova(M1, type = 3)
drop1(M1,test = "F", trace = TRUE)
drop1(M1, .~., test="F", trace = TRUE)

# Stepwise selection of linear model (lm())
M1AIC <- stepAIC(update(M1, .~.), direction = "both", k= 2)
M1AIC$anova
AIC(M1AIC) #586.7715 #736.86 06/04/2023 -BAR

plot(M1AIC)
plot_model(M1AIC, type = "diag")
#Final Model:
#logit_herbivory ~ LMA + Species + Thickness + E_load
#
#Careful, Species will be used as a random effect.
```

Using AIC values for model selection results in the final model: AIC = 586.1367: Ant_percent_leafloss ~ Species + LMA + E_load.x

As of 06/04/2023:
The final model as a results of `setAIC()` is:
logit_herbivory ~ LMA + Species + Thickness + E_load

## Random effect models with fixed terms
### ANTS: Leaf traits and Herbivory

Models for predicting herbivory loss using FEF community diversity. Use of raw functional leaf trait values.

### ML: fixed terms

```{r, Ant masterant2 ML model selection, tidy = TRUE}
#Using results from stepAIC() as the starting point.
#Using Maximum Likelihood (ML) to model.

# ANTS: Species as random effect, NO interactions
# M3 ####
M3 <- lme(logit_herbivory ~ Thickness + Toughness + LMA + Anthocyanins + E_load, random = ~1 | Species, method = "ML", data = masterant2, na.action = na.exclude)
summary(M3) #Adding the random effect INCREASES AIC score.
AIC(M3) #599.7568 # 1928.168 as of 5/23/23
# 759.54 as of 06/04/2023

# Residuals histograms and plots ####
M3_resid <- resid(M3, type = "response")
M3_fitted <- fitted(M3)

hist(M3_resid)
hist(M3_fitted)

plot(M3) 
plot_model(M3, type = "diag") # The residuals spread increases slightly as the fitted values increase. Indicating heterogeneity.

# Stepwise selection of terms
M3.step <- stepAIC(update(M3, .~.), direction = "both", k= 2)
M3.step$anova
AIC(M3.step) #Step:  AIC = 596.744 Ant_percent_leafloss ~ E_load.x  # as of 5/23/23 Final Model:logit_herbivory ~ Thickness + LMA + E_load

# ANOVAs
Anova(M3.step, type = 3)
drop1(M3.step, .~., test="Chisq", trace = TRUE)

# M4 ####
# Nesting Species and E_load
M4 <- lme(logit_herbivory ~ Thickness + LMA, random = ~1 | Species/E_load, method = "ML", data = masterant2, na.action = na.exclude)

summary(M4) #Nestin E_load in Species term INCREASES AIC score.
AIC(M4) #604.2886 # 1936.182 as of 5/23/23 # 768.2949 06/04/2023

# Residuals histograms and plots ####
M4_resid <- resid(M4, type = "response")
M4_fitted <- fitted(M4)

hist(M4_resid)
hist(M4_fitted)

plot(M4)
plot_model(M4, type = "diag")

# Nesting E_load in Species INCREASES the AIC score.
```

Model M1 (lm(y~a+b+c+d)) remains as the model with the lowest AIC value. 

## Random effect models with interactions
### ML: interactions 

```{r, Ant RAW ML interactions, tidy = TRUE}
# M5: modelling interactions_ No E_load.x, Total_reads and Observed richness #### 
# Using the fixed terms from M1 model.
M5 <- lme(logit_herbivory ~ Anthocyanins * Toughness* Thickness  * LMA  * E_load, random = ~1|Species, method = "ML", data = masterant2, na.action = na.exclude) #Observed richness is confounded by Shannon diversity, probably. The same happens with Toughness and Thickness. 
summary(M5)
AIC(M5) #601.8333 Decreases slightly # 1912.486 as of 5/23/23 # 770.3784 as of 06/04/2023 IT INCREASEs

M5.step <- stepAIC(update(M5, .~.) , direction = "both", k= 2)
M5.step$anova

# Residuals histograms and plots
M5_resid <- resid(M5, type = "response")
M5_fitted <- fitted(M5)

hist(M5_resid)
hist(M5_fitted)

plot(M5)
plot_model(M5, type = "diag")

# Not the best model
```

### REML: interactions
Using Restricted Maximum Likelihood (REML) to model. Maximum likelihood tends to be biased with high dimensional data.
No interactions yet, checking random effects.

```{r, Ant masternat2 RAW REML model selection, tidy = TRUE}
# REML

#M1REM All fixed terms
M1REM <- lme(logit_herbivory ~ Anthocyanins + Toughness + Thickness  + LMA + E_load, random = ~1 | Species, method = "REML", data = masterant2, na.action = na.exclude)

plot(M1REM)
summary(M1REM)
AIC(M1REM) # 492.533 BETTER! # 1895, as of 5/23/23 BETTER still! # 755.8854 as of 06/04/2023 NOT BETTER

M1.gls <- gls(logit_herbivory ~ Anthocyanins + Toughness + Thickness  + LMA + E_load, method = "REML", data = masterant2, na.action = na.exclude)

plot(M1.gls)
summary(M1.gls)
AIC(M1.gls) #589.6144 # 1955.694 as of 5/23/23 # 797.37 as of 06/04/2023
```

Random effect "Species" REDUCES the AIC score. It is important then! 

### REML: Variance Structure
```{r}
# M2REM: Removed Toughness from M1REM
M2REM <- lme(logit_herbivory ~  Anthocyanins + Thickness  + LMA + E_load, random = ~1 | Species, method = "REML", data = masterant2, na.action = na.exclude) #

#Validation
plot(M2REM)
summary(M2REM)
AIC(M2REM) #594.0651 # 1934.192 as of 5/23/23 # 756.3651 as of 06/04/2023

#The spread of residuals vs. fitted values improves so does AIC value. 

# Model M2REM without E_load and LMA INCREASES AIC score of model.
# nested random effect (~1|Species/E_load)


#Maybe there is some variance structure...

#Optimizers
ctrl <- lmeControl(opt='optim')
ctrl2 <- lmeControl(opt = "nlminb")

#M3REM: Same fixed terms as M2REM
M3REM <- lme(logit_herbivory ~  Anthocyanins + Thickness  + LMA + E_load, weights = varIdent(form = ~ 1|Species),  random = ~ 1 | Species, method = "REML", control = ctrl, data = masterant2, na.action = na.exclude)

plot(M3REM)
summary(M3REM)
AIC(M3REM) #584.711 #1902.209 as of 5/23/23 # 746.3538 as of 06/04/2023

# Manual Model validation
# op <- par(mfrow = c(3, 2), mar = c(4, 4, 2, 2))
# plot(masterant2$Ant_percent_leafloss, jitter(resid(M3REM, type = "response")), xlab = "LOGIT_HERB", ylab = "Ordinary Residuals")
# abline(h = 0, col = "blue")
# plot(masterant2$Ant_percent_leafloss, jitter(resid(M3REM, type = "normalized")), xlab = "LOGIT_HERB", ylab = "Norm/standarized Residuals")
# abline(h = 0, col = "blue")
# plot(masterant2$Thickness, jitter(resid(M3REM, type = "response")), xlab = "Thickness", ylab = "Ordinary Residuals")
# abline(h = 0, col = "blue")
# plot(masterant2$Thickness, jitter(resid(M3REM, type = "normalized")), xlab = "Thickness", ylab = "Norm/standarized Residuals")
# abline(h = 0, col = "blue")
# plot(masterant2$LMA, jitter(resid(M3REM, type = "response")), xlab = "LMA", ylab = "Ordinary Residuals")
# abline(h = 0, col = "blue")
# plot(masterant2$LMA, jitter(resid(M3REM, type = "normalized")), xlab = "LMA", ylab = "Norm/standarized Residuals")
# abline(h = 0, col = "blue")
# 
# #
# par(mfrow = c(1,2))
# plot(fitted(aglm_ident), resid(aglm_ident, type="normalized"), cex.axis=.5,
# cex=.4, xlab="fitted values", ylab="standardized resid", cex.lab=.8)
# plot(LDEtraits$Species, resid(aglm_ident, type="normalized"), cex.axis=.5,
# cex=.4, xlab="Species", ylab="standardized resid", cex.lab=.8)
# abline(h = 0, col = "blue")
```

The spread of residuals vs. fitted values improves for M2REM and so does AIC value. Model M3REM has the lowest AIC value and the spread of residuals vs fitted values is more constant/even throughout. There are still signs of heteroskedasticity, but better. There is variance structure  at the species levels. Among the REML models M3REM is the best fit.

Let's continue.
```{r}
# M4REM: Same terms as M3REM, but nesting E-load in Species
M4REM <- lme(logit_herbivory ~ Anthocyanins + Thickness  + LMA,  weights = varIdent(form = ~ 1|Species),  random = ~ 1 | Species/E_load, method = "REML", control = ctrl, data = masterant2, na.action = na.exclude)

# Validation
plot(M4REM)
summary(M4REM)
AIC(M4REM) #575.565 # 756 as of 06/04/2023
plot_model(M4REM, type = "diag")
```

Worst than M3REM. Nesting E-load in Species does not improve the model.

Let's finally model with interactions.

```{r}
#M5_INTERACTIONS
#Also exploring linear mixed models using lme4 package

M5REM <- lme(logit_herbivory ~ Anthocyanins * Thickness  * LMA * E_load, weights = varIdent(form = ~ 1|Species),  random = ~ 1 | Species, method = "REML", control = ctrl, data = masterant2, na.action = na.exclude)

#Validation
plot(M5REM)
summary(M5REM)
AIC(M5REM) # 527 AIC # 1571.156 as of 5/23/23 # 704.2486 as of 06/04/2023

plot(M5REM)
logit_est <- plot_model(M5REM, type = "diag")
logit_est
tab_model(M5REM)

#ggsave(filename = "./Plots/Aim3_Ant_estimates_GLM_06042023.jpg", plot = logit_est, dpi = 600, units = "mm", width = 150, height = 180)


#Let's see if I can lower the AIC score more.

# Although this model has the lowest AIC score, it does have predictor variables that are collinear (LMA & Toughness), which confounds the interpretation of the results.


## Manual model selection ####

#From the previous section I can see that model M4 and M5 have the lowest AIC scores. This is achieved by modeling interaction of the explanatory variables. Yet some interaction do not seem to be significant. What is the most parsimonious model I can achieve?

#This doesn't make much sense to me. Sure E_load reduces the AIC score but of course it is going to have an impact or predict well herbivory loss. It is a treatment, not a continuous explanatory variable. It just does not fit the question well.
#
```


### Conclusions of model selection using REML model estimation

The interaction between *\logit?herbivory ~ Anthocyanins : Toughness : Thickness : LMA :E_load,  random = ~1 | Species, weights = varIdent(form = ~ 1|Species)* is the best fit model with random effect (Species). We are trying to understand how FEF diversity influences herbivory on an per species/plant basis. The variance structure seems to not be nested. Hence, no need to nest Species/E_load. 

### sjPlot
### Plotting Estimates (Fixed Effects) of Best Fit model
Using [`sjPlot`](https://strengejacke.github.io/sjPlot/articles/plot_model_estimates.html) package to visualize model estimates. 

```{r, sjPlot visualizations, tidy = TRUE}
# Regression model table
# M2.lme, M5, M6

tab_model(M3REM, 
         show.solutions = TRUE, 
          show.aic = TRUE, 
          show.intercept = TRUE, 
          show.df = TRUE, 
          df.method = "satterthwaite",
          title = "Linear mixed effects models for predicting leaf herbivory", 
          CSS = list(
            css.depvarhead = 'font-weight:bold;',
            css.centeralign = 'text-align: left;',
            css.firsttablecol = 'font-weight: bold;',
            css.summary = 'color: blue; font-weight: bold;',
            p.style = "numeric_stars")
    )

#Reproducible example
# mtcars$fact_cyl <- as.factor(mtcars$cyl)
# 
# lm1 <- lme(mpg ~ cyl, mtcars)
# lm2 <- lme(mpg ~ hp, mtcars)
# lm3 <- lme(mpg ~  hp + gear, random = ~1|fact_cyl, mtcars)
# 
# AIC(lm1, lm2, lm3)
# 
# tab_model(lm1,
#           show.re.var = T,
#           show.aicc = TRUE,
#           show.intercept = TRUE,
#           df.method = "normal",
#           p.val = "satterhwaite")



# Model estimate plots
# Model 
modCoeff <- plot_model(M5REM, vline.color = "black", sort.est = TRUE, transform = NULL, dot.size = 3, value.offset = .4,
  value.size = 4, title = "Best fit linear mixed effects model coefficients for predicting leaf herbivory") +
  theme_sjplot()
modCoeff

#ggsave(filename="Aim3_GLM_Coeff_estimates.jpeg", plot = modCoeff, dpi=600, units=c("mm"), width=200, height=200)

# Best fit model standarized coeeficients
stCoeff <- plot_model(M5REM, type = "std", vline.color = "black", sort.est = F, transform = NULL, dot.size = 3, value.offset = .4,
  value.size = 4, title = "Best fit GLM model coefficients for predicting leaf herbivory (standarized coefficients)")
stCoeff
#ggsave(filename="Aim3_GLM_STDCoeff_estimates.jpeg", plot = stCoeff, dpi=600, units=c("mm"), width=200, height=200)

# best fit model slope predictions
#
# Simple diagnostic-plots, where a linear model for each single predictor is plotted against the response variable, or the model's residuals. Additionally, a loess-smoothed line is added to the plot. The main purpose of these plots is to check whether the relationship between outcome (or residuals) and a predictor is roughly linear or not. Since the plots are based on a simple linear regression with only one model predictor at the moment, the slopes (i.e. coefficients) may differ from the coefficients of the complete model.
#slope <- plot_model(M6REM,  type =  "slope")
plot_model(M6REM, type = "diag")
#ggsave(filename = "Aim3_GLMSlope_LeafTraits_06272022.jpeg", plot = slope, dpi=600, units=c("mm"), width=200, height=200)
```


## Plots: Ants
### LM plots
```{r, ggplot Magic}
par(mfrow = c(1, 1))
wes_paleta2 <- wes_palette(name = "Darjeeling1", 2, type = "continuous")

#Boxplot
hbox <-  ggplot(data = masterant2, aes(x = Species, y = Ant_percent_leafloss), color = Species) +
  geom_violin(aes(fill = E_load),outlier.shape = NA) +
  geom_crossbar(stat="summary", fun = mean, fun.max = mean, fun.min = mean,  fatten = 2, width = 0.5) +
  scale_fill_manual(values = wes_paleta2)+
  geom_jitter(color="grey20", size = 2, alpha= 0.5) +
  theme_minimal(base_size = 12) +
  theme(legend.position="right", 
         legend.title = element_blank(),
         legend.text = element_text(size = 16),
         axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x="", y="Leaf Herbivory (%)", caption = "*All replicate leaves from tree species included  (n = 210)") +
  annotate("text", x = 2.5, y = .65, label = "")
  # stat_compare_means(comparisons = mycomparisons ) +
  # stat_compare_means(method = "kruskal.test", label = "p.signif")
hbox

# Ant
# Regressions
# Herbivory and Toughness
  
t <-ggplot(data = masterant2, aes(y= logit_herbivory, x = Toughness, color = E_load)) +
   geom_jitter(aes(color = E_load, shape = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se = F) +
 # stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = 2.5, label.x = 0.45, aes(label = ..eq.label..), sep = "~~~~", size = rel(3), color= "black") +
  stat_regline_equation(label.y = 2 , label.x = 0.45, aes(label = ..adj.rr.label..), size = rel(3),color = "black") +
  labs(x="Leaf Toughness (lbf)", y = "logit(Leaf herbivory) (%)") +
  theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend
#caption = "**All replicate leaves from tree species included  (n = 210)", col = "Treatment"
t

# fit <- lm(logit_herbivory ~ Thickness, data = masterant2)
# 
# rSquared <- summary(fit)$r.squared
# rSquared
# anova(fit)
# pVal <- anova(fit)$'Pr(>F)'[1]
# pVal
# Herbivory and Anthocyanins

a <- ggplot(data = masterant2, aes(y= logit_herbivory, x= Anthocyanins, color = E_load))+
   geom_jitter(aes(color = E_load, shape = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se=F) +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = 2.5, label.x = 5, aes(label = ..eq.label..), size = rel(3), color= "black") +
  stat_regline_equation(label.y = 2 , label.x = 5, aes(label = ..adj.rr.label..), size = rel(3), color = "black") +
  labs(x="Anthocyanins (ACI)", y="logit(Leaf herbivory) (%)") +
  theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title =element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend
 
a
#scale_shape_manual(values = c(1:7))

# Herbivory and leaf thickness

tt <- ggplot(data = masterant2, aes(y= logit_herbivory, x= Thickness, color = E_load))+
   geom_jitter(aes(color = E_load, shape = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se=F) +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = 2.5, label.x = 200, aes(label = ..eq.label..), size = rel(3), color= "black") +
  stat_regline_equation(label.y = 2 , label.x = 200, aes(label = ..adj.rr.label..), size = rel(3), color = "black") +
  labs(x="Leaf thickness (\u03BCm)", y = "logit(Leaf herbivory) (%)") +
 theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none")
tt

# Herbivory and LMA

lma <- ggplot(data = masterant2, aes(y= logit_herbivory, x= LMA, color = E_load))+
  geom_jitter(aes(color = E_load, shape = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se=F) +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = 2.5, label.x = 0.001, aes(label = ..eq.label..), size = rel(3), color= "black") +
  stat_regline_equation(label.y = 2 , label.x = 0.001, aes(label = ..adj.rr.label..), size = rel(3), color = "black") +
  labs(x="Leaf mass per area (LMA)", y = "logit(Leaf herbivory) (%)") +
  theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend
 
lma

# Herbivory and FEF Shannon Diversity
# Extracting effect size of model to plot
 dv <- ggplot(data = masterant2, aes(y= logit_herbivory, x= Shannon, color = E_load))+
  geom_jitter(aes(color = E_load, shape = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se=F) +
 # stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  #scale_fill_manual(values= met.brewer("Cross", n = 8, type = "discrete")) +
  #scale_color_manual(values= met.brewer("Cross", n = 8, type = "discrete")) +
  stat_regline_equation(label.y = 2.5, label.x = 1.5, aes(label = ..eq.label..),size = rel(3), color= "black") +
  stat_regline_equation(label.y = 2 , label.x = 1.5, aes(label = ..adj.rr.label..), size = rel(3),color = "black") +
  labs(x="Shannon diversity index", y="logit(Leaf herbivory) (%)") +
  theme_minimal(base_size = 10) +
 theme(legend.position="right",
        legend.text = element_text(size = 12),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7))
  # guides(color = "none")  +      #To turn off color legend
  # guides(fill = "none") + #To turn off fill legend
  # guides(shape = "none") #To turn off shape legend
 
 dv

 # Multiples plots together

ant_arranged <- ggarrange(t, tt, a, lma, dv, nrow = 2, ncol=3, common.legend = TRUE, legend="right")


# Adding caption
ant_caption <- "*All individuals per tree species included (n = 210)"
ant_arranged_with_caption <- annotate_figure(ant_arranged, bottom = text_grob(ant_caption), fig.lab.pos = "bottom.right", fig.lab.size = 6)

ant_arranged_with_caption

#ggsave(filename = "./Plots/Aim3_ant_regression_06042023.jpg", plot = ant_arranged_with_caption, dpi=600, units=c("mm"), width=180, height=140, bg = "white")

```



# Pathogen Analyses

## Descriptive statistics
Refer to the ANTS section for descriptive statistics and non-normality of predictor(independent variables).
```{r}

# Evaluating non-normality of the data ####
#Do not use "master" data set to assess the assumption of normality. It includes duplicate information for the explanatory variables. Meaning a sample and its data are paired multiples times with the OTU's that are present in it. Use either "data" or "newdata".

#Proceeding with exploring normality assumptions with "data" and "masterant". It retaines the mean values for all leaf replicates.

# QQPlots ####
#qqPlot(rnorm(n = length(data$Anthocyanins..aci.), 
             #mean =mean(data$Anthocyanins..aci., na.rm = TRUE), 
             #sd = sd(data$Anthocyanins..aci., na.rm = TRUE)))
             
#Using "data" set
qqPlot(data$Anthocyanins..aci.)
qqPlot(data$Thickness..micro.m.)
qqPlot(data$Toughness..lbf.)
qqPlot(data$LMA_dw)

# 
# masterpat$Prop_area_loss <- masterpat$Pathogen_area_loss/100
# 
# qqPlot(masterpat$Prop_area_loss)

# QQPlots Using "masterpat"

qqPlot(masterpat$Pathogen_Damage_area)
qqPlot(masterpat$Anthocyanins)
qqPlot(masterpat$Thickness)
qqPlot(masterpat$Toughness)
qqPlot(masterant$LMA)
qqPlot(masterant$Shannon)

#Nothing has a normal distribution. It looks like it will be necessary to use a negative binomial distribution. 

# Shapiro-Wilks tests ####
#shapiro.test(rnorm(n = length(data$Anthocyanins..aci.), 
                   #mean =mean(data$Anthocyanins..aci., na.rm = TRUE), 
                   #sd = sd(data$Anthocyanins..aci., na.rm = TRUE)))
                   #shapiro.test(masterant$Prop_area_loss)
                   
#After seeing the non-normal distributions and the potential complications of evaluating incomplete data (i.e. NA), I decided to eliminate NA's. Refer to section "Master data" to see code for eliminating NA's. 
                 
# Using "masterant". This data set does not have NA's
hist(masterpat$Pathogen_Damage_area) #Skewed to the left
shapiro.test(masterpat$Pathogen_Damage_area) #Data deviates from the normal distribution. p-value = 7.263e-12
shapiro.test(masterpat$Anthocyanins) #Non-normal p-value = 0.0001326
shapiro.test(masterpat$Thickness) #Non-normal p-value = 7.098e-05
shapiro.test(masterpat$Toughness) #Non-normal p-value = 2.048e-09
hist(masterpat$Toughness)
shapiro.test(masterpat$LMA) #Non-normal p-value = 5.409e-06
shapiro.test(masterpat$Shannon) #Non-Normal p-value = 0.001621
hist(masterpat$Shannon)


# Pathogen_area_loss is not normally distributed. Skewed to the left.

#Conclusion from the Shapiro-Wilk tests. Some of the independent variables are not normally distributed. 

# Re-eveluating autocorrelation of terms ####

# Variance Inflation Factor on simple LM with Toughness and Thickness

vif(lm(Pathogen_Damage_area ~ Anthocyanins + Thickness + Toughness + LMA + Observed + Shannon + Total_reads + Relative_Abundance, data = masterpat))
#Variance inflation factors range from 1 upwards. The numerical value for VIF tells you (in decimal form) what percentage the variance (i.e. the standard error squared) is inflated for each coefficient. For example, a VIF of 1.9 tells you that the variance of a particular coefficient is 90% bigger than what you would expect if there was no multicollinearity — if there was no correlation with other predictors.
#A rule of thumb for interpreting the variance inflation factor:

#1 = not correlated.
#Between 1 and 5 = moderately correlated.
#Greater than 5 = highly correlated.

# All explanatory variables have a VIF that is moderately correlated.
# cor()
corr <- cor(masterpat[,c(7:16)])
corr
corrplot::corrplot(corr, type="upper", order="hclust")

#To compute the matrix of p-value, a custom R function is used :

# mat : is a matrix of data
# ... : further arguments to pass to the native R cor.test function
cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j], ...)
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}
# matrix of the p-value of the correlation
p.mat <- cor.mtest(corr)
head(p.mat[, 1:8])

corrplot::corrplot(corr, method = "color", type = "upper", order = "hclust",addCoef.col = "black", # Add coefficient of correlation
         tl.col="black", tl.srt=45, #Text label color and rotation
         # Combine with significance
         p.mat = p.mat, sig.level = 0.05, 
         # hide correlation coefficient on the principal diagonal
         diag=FALSE
         )
# From this autocorrelation matrix I can see that the Observed richness, Shannon diversity and Total_reads have low autocorrelation the physical leaf functional traits. These three measures of community composition are somewhat correlated. Especially the Observed species richness and the Shannon diversity index (0.719735754) and Total_reads*Shannon(-0.3244523). For this reason I am going to stick to using Shannon diversity are a community traits for predicting leaf herbivory and pathogenicity. 
# LMA is highly collinear with Anthocyanins and Toughness, while it has very low correlation with Ant_percent_leafloss. I will not include ANthocyanins in the linear models. Thickness and toughness are inversely correlated with each other. Toughness seems to have a low negative correlation with Ant_percent_leafloss. I will not include it in the liinear models. 

```


## Paired T-tests
```{r, Pathogen Assay Paired T-tests, tidy = TRUE}

t.test(formula = Pathogen_Damage_area ~ E_load,
  alternative = "two.sided",
       mu = 0, 
       paired = T,   
       var.equal = TRUE,
       na.rm = FALSE,
       conf.level = 0.95, data = masterpat)
 plot(Pathogen_Damage_area ~ E_load, data = masterpat)
pat_paired <- ggplot(masterpat, aes(E_load, Pathogen_Damage_area)) +
  geom_boxplot(aes(fill = Species))
pat_paired

#ggsave(filename = "pathogen_paired.png", plot = pat_paired, dpi=600, units=c("mm"), width=300, height=300)
#
#
#The code below is for creating df with t-test results. The `rstatix` package can group and organize data frame by the "group" needed and provide results of t.test comparisons. 
## install.packages('rstatix')
# library(rstatix)
# t.test(formula = Pathogen_Damage_area ~ Treatment,
#   alternative = "less",
#        mu = 0, 
#        paired = T,   
#        var.equal = TRUE,
#   na.rm = FALSE,
#        conf.level = 0.95, data = masterpat)
# 
# pat_pairedt <- masterpat %>%
#   rstatix::group_by(Species, Treatment) %>%
#   pairwise_t_test(Pathogen_Damage_area ~ E_load, 
#                 p.adjust.method = "bonferroni",
#                 paired = T,
#                 alternative = "less")
#write.csv(pat_pairedt, file = "pathogen_pairedT.csv")
```


## Pathogen Linear Mixed Models: raw functional leaf traits.

Now that we have answered how the leaf functional traits influence FEF community diversity, we can see how endophyte community diversity influences the effects of pathogenicity. 

```{r, tidy = TRUE}
# For reference
#Models from ANTS models
#y ~ Anthocyanins + Thickness + Toughness + LMA +E_load + Shannon + Observed + Total_reads

#B1 <- glm(Prop_area_loss ~ Anthocyanins + Thickness +Toughness + LMA + Shannon + (1+ Species), family = gaussian(link = "identity"), data = masterant, na.action = na.exclude)
#plot(B1)
#AIC(B1)
#plot_model(B1, type = "diag")
#plot_model(B1)
#Anova(B1, type = 3)
##

##Pathogen
# Model with intercept only ####

P0 <- lm(Pathogen_Damage_area ~ 1, data = masterpat, na.action = na.exclude)
plot(P0)

# P1 ####

P1 <- lm(Pathogen_Damage_area ~ Anthocyanins + Species + LMA + Toughness + Thickness + E_load + Shannon, data = masterpat, na.action = na.exclude) #Model with all continuous explanatory variables.

summary(P1)
AIC(P1) # 1488

# Residuals
P1_resid <- resid(P1, type = "response")
P1_fitted <- fitted(P1)

#Histograms
hist(P1_resid)
hist(P1_fitted)

# Plots
plot(P1)
plot_model(P1, type = "diag")

# Stepwise selection of linear model (lm())

P1AIC <- stepAIC(update(P1, .~.), direction = "both", k = 2)
P1AIC$anova
AIC(P1AIC) #1056.611

# Three ways to get type 3 anova. The first one requires that there are no atomic vector. The ;linear regression has to be coded in one line, not creating chorthand foremula. The rest are pretty self evident. For drop1(model,.~., test = "F) we obtain the same as Anova() from the "car" package. Without the .~. we obtain terms or interactions that are not significant. 

#anova(P1,type="marginal") #What is a type III ANOVA?
Anova(P1, type = 3)
drop1(P1,test = "F", trace = TRUE)
drop1(P1, .~., test="F", trace = TRUE)

# P2#### Removed Anthocyanins and Toughness due to high colinearity with LMA
P2 <- lm(Pathogen_Damage_area ~  Species + E_load + Thickness + LMA + Shannon, data = masterpat, na.action = na.exclude)
summary(P2)
AIC(P2) #1062.756

# Residuals
P2_resid <- resid(P2, type = "response")
P2_fitted <- fitted(P2)
#Histograms
hist(P2_resid)
hist(P2_fitted)

# Plots
plot(P2)
plot_model(P2, type = "diag")

#Anthocyanins and leaf thickness seem to be the best predictors of leaf area loss due to herbivory

# Stepwise selection of linear model (lm())
P2AIC <- stepAIC(update(P2, .~.), direction = "both", k= 2)
P2AIC$anova
AIC(P2AIC) #1056.611

plot(P2AIC)
```


## Random effect models with fixed terms

### PATHOGEN: Endophyte Diversity
### ML: fixed terms

```{r, Pathogen RAW ML model selection, tidy = TRUE}
#Using results from stepAIC() as the starting point.
#Using Maximum Likelihood (ML) to model.

# PATHOGEN: Species as random effect, NO interactions
# P3 ####
P3 <- lme(Pathogen_Damage_area ~ E_load + Thickness + LMA + Shannon, random = ~1 | Species, method = "ML", data = masterpat, na.action = na.exclude)
summary(P3) #Adding the random effect INCREASES AIC score.
AIC(P3) #1070.544

# Residuals histograms and plots ####
P3_resid <- resid(P3, type = "response")
P3_fitted <- fitted(P3)

hist(P3_resid)
hist(P3_fitted)

plot(P3) 
plot_model(P3, type = "diag") # The residuals spread increases slightly as the fitted values increase. Indicating heterogeneity.


# P4 ####
# Nesting Species and E_load
P4 <- lme(Pathogen_Damage_area ~ Thickness + LMA + Shannon, random = ~1 | Species/E_load, method = "ML", data = masterpat, na.action = na.exclude)

summary(P4) #Removing E_load term and nesting it INCREASES AIC score.
AIC(P4) #1071.655

# Residuals histograms and plots ####
P4_resid <- resid(P4, type = "response")
P4_fitted <- fitted(P4)

hist(P4_resid)
hist(P4_fitted)

plot(P4)
plot_model(P4, type = "diag")

# Nesting E_load in Species INCREASES the AIC score.
```

### REML: fixed terms
```{r, Restricted Maximum Likelihood (REML), tidy = TRUE}
# REML

#No interactions yet, checking random effects
#
#P1REM
P1REM <- lme(Pathogen_Damage_area ~ Thickness + LMA + E_load + Shannon, random = ~1 | Species, method = "REML", data = masterpat, na.action = na.exclude)
summary(P1REM)
AIC(P1REM) # 1046.999 BETTER!
P1.gls <- gls(Pathogen_Damage_area ~ Thickness + LMA + E_load + Shannon, method = "REML", data = masterpat, na.action = na.exclude)
summary(P1.gls)
AIC(P1.gls) #1054.015

#Random effect "Species" REDUCES the AIC score. It is important then! 

# P2REM: No Total_reads, tHICKNESS, Toughness, LMA, and, Observed richness
P2REM <- lme(Pathogen_Damage_area ~  LMA + E_load + Shannon, random = ~1 | Species, method = "REML", data = masterpat, na.action = na.exclude)
summary(M2REM)
AIC(P2REM) #1041.034

# Model P2REM has lowest AIC score.

# M3REM####
#Maybe there is some variance structure...
ctrl <- lmeControl(opt='optim')

P3REM <- lme(Pathogen_Damage_area ~  LMA + Thickness + Shannon, weights = varIdent(form = ~ 1|Species),  random = ~ 1 | Species/E_load/Treatment, method = "REML", control = ctrl, data = masterpat, na.action = na.exclude)
summary(P3REM)
AIC(P3REM) #1030.331

#P3REM has the lowest AIC yet!

# Model P3REM with nested variance structure for Species/E_load/Treatment definitely DECREASES AIC value. 
# 
plot_model(P3REM, type = "diag")
#The graphical evaluation does not look good. 
# 
# P4REM #### 
P4REM <- lme(Pathogen_Damage_area ~  LMA + Thickness + Shannon + Treatment + E_load, random = ~1 | Species, method = "REML", data = masterpat, na.action = na.exclude)
summary(P4REM)
AIC(P4REM) #981.4897
```

## Random effect models with interactions

#### ML: interactions

```{r, Maximum Likelihood}
# P5: modelling interactions_ No E_load, Total_reads and Observed richness #### 
# Using the fixed terms from M1 model.
P5 <- lme(Pathogen_Damage_area ~ Thickness  * LMA * Shannon * E_load, random = ~1|Species, method = "ML", data = masterpat, na.action = na.exclude) #Observed richness is confounded by Shannon diversity, probably. The same happens with Toughness and Thickness. 
summary(P5)
AIC(P5) #1088.681 INCREASES

P5.step <- stepAIC(update(P5, .~.) , direction = "both", k= 2)
P5.step$anova

# Residuals histograms and plots
P5_resid <- resid(P5, type = "response")
P5_fitted <- fitted(P5)

hist(P5_resid)
hist(P5_fitted)

plot(P5)
plot_model(P5, type = "diag")

# Not the best models!
```

### REML: 
Using Restricted Maximum Likelihood (REML) to model. Maximum likelihood tends to be biased with high dimensional data.

Let's model with interactions and remove variance structure. Having Treatment and E_load as fixed effect reduces AIC score.
```{r, Pathogen RAW REML interactions, tidy = TRUE}
#P5_INTERACTIONS_
P5REM <- lme(Pathogen_Damage_area ~  LMA * Thickness * Shannon * Treatment * E_load, random = ~1 | Species, method = "REML", data = masterpat, na.action = na.exclude)
summary(M5REM)
AIC(P5REM) #789.1233 DECREASE AIC
plot(P5REM)
plot_model(P5REM, type = "diag")

#Let's see if I can lower the AIC score more.

# P6 Interaction between terms - nested random effects  No E_load E_load, Total_reads, and Observed Richness
P6REM <- lme(Pathogen_Damage_area ~  LMA * Thickness * Shannon * Treatment , random = ~ 1 | Species, method = "REML", data = masterpat, na.action = na.exclude)
summary(P6REM)
AIC(P6REM) #904.3554
plot_model(P6REM, type = "diag")
#REMOVAL OF E_LOAD INCREASES AIC SCORE.

# P7 
P7REM <- lme(Pathogen_Damage_area ~  LMA * Thickness * Shannon *  E_load * Treatment, random = ~ 1 | Species, method = "REML", data = masterpat, na.action = na.exclude)
AIC(P7REM) #842.9074

#What if I coalesce Treatment and E_load? That way it becomes a binary factor fixed term. 

masterpat$Treat_Eload <- paste(masterpat$E_load, masterpat$Treatment)

P8REM <- lme(Pathogen_Damage_area ~  LMA * Thickness * Shannon *  Treat_Eload, random = ~ 1 | Species, method = "REML", data = masterpat, na.action = na.exclude)
AIC(P8REM) #789.1233

#Concatenating the columns does nothing. It has the same AIC score than P5REM.


```

### Conclusions of model selection with raw functional leaf traits
I think I need to transform the data: Pathogen damage. There is too much non-normality. The variance structure seems to not be nested. Hence, no need to nest Species/E_load. 

## Plots: Pathogen
### LM plot

```{r, logit(Pathogen damage) vs Leaf traits and Shannon diversity, tidy = TRUE}

par(mfrow = c(1, 1))
wes_paleta2 <- wes_palette(name = "Darjeeling1", 2, type = "continuous")

# Pathogen Boxplot
pbox <-  ggplot(data = masterpat2, aes(x = E_load, y = Pathogen_percent_damage), color = Species) +
  geom_violin(aes(fill = E_load)) +
  geom_crossbar(stat="summary", fun = mean, fun.max = mean, fun.min = mean,  fatten = 2, width = 0.5) +
  scale_fill_manual(values = wes_paleta2)+
  geom_jitter(color="grey20", size = 2, alpha= 0.5) +
  theme_minimal(base_size = 10) +
  theme(legend.position="right", 
         legend.title = element_blank(),
         legend.text = element_text(size = 16),
         axis.text.x = element_blank()) + 
  theme(panel.grid.major = element_line(colour = "grey")) +
  theme(panel.grid.minor = element_line(colour = "grey")) +
  theme(strip.background = element_rect(fill = "white")) +
  theme(strip.text.x = element_text(colour = "black", face = "bold")) +
  theme(legend.title = element_text(face = "bold")) +
  theme(panel.border = element_rect(linetype = "blank", fill = NA)) +
  #(angle = 45, hjust = 1)) +
  labs(x="", y="Pathogen damage (%)") +
  annotate("text", x = 2.5, y = .65, label = "") +
  facet_wrap(~Species)
  # stat_compare_means(comparisons = mycomparisons ) +
  # stat_compare_means(method = "kruskal.test", label = "p.signif")
pbox

# Pathogen
# Regressions
# Pathogen damage and Toughness
  
pt <-ggplot(data = masterpat2, aes(y= Pathogen_percent_damage, x = Toughness, color = E_load)) +
   geom_jitter(aes(color = E_load, shape = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se = F) +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = .75, label.x = 0.45, aes(label = ..eq.label..), sep = "~~~~", size = rel(3), color= "black") +
  stat_regline_equation(label.y = .55 , label.x = 0.45, aes(label = ..adj.rr.label..), size = rel(3), color = "black") +
  labs(x="Leaf Toughness (lbf)", y="logit(Pathogen damage) (%)") +
  theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend

pt

# Pathogen damage and Anthocyanins

pa <- ggplot(data = masterpat2, aes(y= logit_damage, x= Anthocyanins, color = E_load))+
   geom_jitter(aes(color = E_load, shape = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se=F) +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = 2.5, label.x = 7, aes(label = ..eq.label..), size = rel(3), color= "black") +
  stat_regline_equation(label.y = 1.5 , label.x = 7, aes(label = ..adj.rr.label..), size = rel(3), color = "black") +
  labs(x="Anthocyanins (ACI)", y="logit(Pathogen damage) (%)") +
  theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend
 
pa
#scale_shape_manual(values = c(1:7))

# Herbivory and leaf thickness

ptt <- ggplot(data = masterpat2, aes(y= logit_damage, x= Thickness, color = E_load))+
   geom_jitter(aes(color = E_load, shape = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se=F) +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = 2.5, label.x = 125, aes(label = ..eq.label..), size = rel(3), color= "black") +
  stat_regline_equation(label.y = 1.5 , label.x = 125, aes(label = ..adj.rr.label..), size = rel(3), color = "black") +
  labs(x="Leaf thickness (\u03BCm)", y="logit(Pathogen damage) (%)") +
  theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none")

ptt


# Pathogen damage and LMA

plma <- ggplot(data = masterpat2, aes(y= logit_damage, x= LMA, color = E_load))+
  geom_jitter(aes(color = E_load, shape = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se=F) +
#  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = 2.5, label.x = 0.00125, aes(label = ..eq.label..), size = rel(3),color= "black") +
  stat_regline_equation(label.y = 1.5 , label.x = 0.00125, aes(label = ..adj.rr.label..), size = rel(3), color = "black") +
  labs(x="Leaf mass per area (LMA)", y="logit(Pathogen damage) (%)") +
  theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend

plma

# Pathogen damage and FEF Shannon Diversity
# Extracting effect size of model to plot
 pdv <- ggplot(data = masterpat2, aes(y= logit_damage, x= Shannon, color = E_load))+
  geom_jitter(aes(color = E_load, shape = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se=F) +
 # stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  #scale_fill_manual(values= met.brewer("Cross", n = 8, type = "discrete")) +
  #scale_color_manual(values= met.brewer("Cross", n = 8, type = "discrete")) +
  stat_regline_equation(label.y = 2.5, label.x = 0.7, aes(label = ..eq.label..), size = rel(3), color= "black") +
  stat_regline_equation(label.y = 1.5 , label.x = 0.7, aes(label = ..adj.rr.label..),size = rel(3), color = "black") +
  labs(x="Shannon diversity index", y="logit(Pathogen damage) (%)", col = "") +
  theme_minimal(base_size = 10) +
  theme(legend.position="right",
        legend.text = element_text(size = 12),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7))
  # guides(color = "none")  +      #To turn off color legend
  # guides(fill = "none") + #To turn off fill legend
  # guides(shape = "none") #To turn off shape legend
 #size = rel(5)
 #, caption = "*All individuals per tree species included (n = 382)",

 pdv
 

#ggsave(filename = "Aim3_EXAMPLE.png", plot = eg, dpi=600, units=c("mm"), width=300, height=300)



 # Arrange Multiples plots together

arranged <- ggarrange(pt, ptt, pa, plma, pdv, nrow = 2, ncol=3, common.legend = TRUE, legend="right")

# Adding caption
caption_text <- "*All individuals per tree species included (n = 382)"
arranged_with_caption <- annotate_figure(arranged, bottom = text_grob(caption_text), fig.lab.pos = "bottom.right", fig.lab.size = 6)

arranged_with_caption

#Saving
#ggsave(filename ="./Plots/Aim3_Pathogen_regression_06042023.jpg", plot = arranged_with_caption, dpi= 600, units=c("mm"), width=180, height=140, bg = "white")

```

# Dimensionality Reduction of leaf traits
## LDA: Linear Discriminant Analyses

"Before performing LDA, consider:
Inspecting the univariate distributions of each variable and make sure that they are normally distribute. If not, you can transform them using log and root for exponential distributions and Box-Cox for skewed distributions.
removing outliers from your data and standardize the variables to make their scale comparable."
http://www.sthda.com/english/articles/36-classification-methods-essentials/146-discriminant-analysis-essentials-in-r/ 

### LDA training
```{r, Ant LDA training, tidy = TRUE}
#Analysis based on C. Lumibao code
#Transform and standarize leaf trait data. They are in different scales and a not normally distributed. 

#Ant
####### Data prep #######
#Subsetting the columns from the data set in order to transform and scale leaf trait variables and diversity measures.

ant_labels <- masterant[,1:4]
ant_std<-masterant[,6:15]

#Scaling
antsc_trait <- scale(ant_std, center = TRUE, scale = TRUE)

#Creating a new data set that is ready from downstream LDA analysis.
ant_lda <- cbind(ant_labels, antsc_trait)


#### Training model ####
#### Splitting the data into training (80%) and test set (20%)

lda.training <- ant_lda %>%
  slice_sample(prop = 0.8)

lda.test <- ant_lda %>%
  slice_sample( prop = 0.2)

### Training ###
lda_train <- lda(Species ~ Anthocyanins * LMA  * Thickness * Toughness * E_load * Shannon * Total_leaf_area_cut,
            data = lda.training, method = "moment")

# Model accuracy
mean(predict(lda_train)$class == lda.test$Species)
#0.1428571

predictions <- lda_train %>% 
  predict(lda.test) #I believe this is saying: predict `lda.test` with the values from `lda_train`.

# Plot training data 
lda.data <- cbind(lda.training, predict(lda_train)$x)

ldaplot <- ggplot(lda.data, aes(LD1, LD2)) 
  ldaplot + geom_point(data = lda.data, aes(color = Species, shape = E_load), size = rel(3), alpha = 0.7)

# Model accuracy
mean(predictions$class == lda.test$Species)
xtabs(~lda.training$Species + predict(lda_train)$class)

```

Conclusion: The ant LDA training model accurately (100%) discriminates the test data set. Modelling interactions achieves 100% accuracy. This validates our model which can be important. Now we proceed with all the data points.

```{r, Pathogen LDA training, tidy = TRUE}
# Pathogen
# Data prep 
#Subsetting the columns from the data set in order to transform and scale leaf trait variables and diversity measures.

pg_labels <- masterpat[,1:6]
pg_std<-masterpat[,7:16]

#Scaling
pgsc_trait <- scale(pg_std, center = TRUE, scale = TRUE)

#Creating a new data set that is ready from downstream LDA analysis.
pg_lda <- cbind(pg_labels, pgsc_trait)


# Training model 
## Splitting the data into training (80%) and test set (20%)

pglda.training <- pg_lda %>%
  slice_sample(prop = 0.75)

pglda.test <- pg_lda %>%
  slice_sample( prop = 0.25)

## Training
pglda_train <- lda(Species ~ Anthocyanins + LMA  + Thickness + Toughness + E_load + Shannon + Pathogen_Damage_area,
            data = pglda.training, method="moment")

# Model accuracy
mean(predict(pglda_train)$class == pglda.test$Species)
#0.1354167

predictions2 <- pglda_train %>% 
  predict(pglda.test) #I believe this is saying: predict `lda.test` with the values from `lda_train`.

# Plot training data 
pglda.data <- cbind(pglda.training, predict(pglda_train)$x)

pgldaplot <- ggplot(pglda.data, aes(LD1, LD2)) 
  pgldaplot + geom_jitter(data = pglda.data, aes(color = Species, shape = E_load), size = rel(3), alpha = 0.7)

# Model accuracy
mean(predictions2$class == pglda.test$Species)
#100% accurate

xtabs(~pglda.training$Species + predict(pglda_train)$class)
```

Conclusion: The pathogen training model accurately (100%) discriminates the test data set. The model does not include interaction to achieve 100% accuracy in linear discrimination. This validates our model which can be important. Now we proceed with all the data points.

### LDA: Full models with functional leaf traits and Shannon diversity
#### Ant 
```{r, Ant LDA with all functional leaf traits, tidy = TRUE}
# Ants

#LDA cannot have NA's if not it will result in Error in x - group.means[g, ] : non-conformable arrays.
#

#This model is asked to discriminate per Species.

ld2a <- lda(Species ~ Anthocyanins + LMA  + Thickness + Toughness + Shannon,
            data = ant_lda, method="moment")

#Model predictions into list
lda.values <- predict(ld2a)

#Model scores
ld2a$scores <- predict(ld2a)$x #coef(ld2a) and ld2a$scaling is the same.

#Extraction of model coefficients 
ld2b <- data.frame(varnames = rownames(coef(ld2a)), coef(ld2a))
ld2b$length <- with(ld2b, sqrt(LD1^2+LD2^2))
# scaling <- data.frame(ld2a$scaling) #Another way of extracting model coefficients.
# scaling <- scaling %>%
#   rownames_to_column(var = "varnames") %>%
#   mutate(length = sqrt(LD1^2+LD2^2))


#only the x variables from predict
ldax <- as.data.frame(lda.values$x)
row.names(ldax)

#Write the predicted values for each samples as a table.
LDtraits <- cbind(ant_lda,ldax)
LDtraits # Use for ggplots


#labels<-data.frame(factor)
#labels

#Model accuracy
mean(LDtraits$Species == lda.values$class)

xtabs(~LDtraits$Species + lda.values$class)

#The model is 90% accurate is discriminating species groups.

#Discriminant axes percent variance explained
prop.lda = ld2a$svd^2/sum(ld2a$svd^2)

#LDA full model plot with ggplot

ldafull <- ggplot(LDtraits, aes(LD1, LD2)) +
  geom_point(data = LDtraits, aes(color = Species, shape = E_load), size = rel(3), alpha = 0.7) +
  stat_ellipse(aes(color = Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1,
               level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
    geom_hline(aes(yintercept=0), size=.2) + geom_vline(aes(xintercept=0), size=.2) +
    geom_segment(data = ld2b,
                      aes(x=0, y=0,
                          xend = LD1, yend = LD2,
                          shape = NULL, linetype = NULL,
                          alpha = length),
                      arrow = arrow(length=unit(0.2,"cm")),
                      color ="red") +
    geom_text(data = ld2b,
                   aes(x=LD1*0.75, y=LD2*0.75,
                       label = varnames, 
                       shape = NULL, linetype = NULL,
                       alpha = length),
                   size = 3, vjust = 0.5,
                   hjust = 0, color = "black") +
    labs(x = paste("LD1 (", round(prop.lda[1]*100, digits = 1), "%)", sep="")) +
    labs(title = "Ants LDA: all E-+, leaf traits and Shannon diversity", caption = "(90% accuracy)", y = paste("LD2 (", round(prop.lda[2]*100, digits = 1), "%)", sep="")) +  
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
   theme(
plot.title = element_text(color="red", size=14, face="bold"))

ldafull 

#ggsave(filename = "Plots/LDAfull_02282023.png", plot = ldafull, dpi=600, units=c("mm"), width=300, height=300)

```
The full model is 90% accurate is discriminating species groups. This is probably due to only modelling fixed effects. No interaction terms are modeled. Previous LDA model (with no Shannon diversity included) had an accuracy of 88% and LD1 and LD2 differed by ~0.5%. Code was updated in February 28, 2023 to include Shannon diversity.

#### Pathogen
```{r, Pathogen LDA with all functional leaf traits, tidy = TRUE}
#Pathogen
# Data prep 
#Subsetting the columns from the data set in order to transform and scale leaf trait variables and diversity measures.

pg_labels <- masterpat[,1:6]
pg_std<-masterpat[,7:16]

#Scaling
pgsc_trait <- scale(pg_std, center = TRUE, scale = TRUE)

#Creating a new data set that is ready from downstream LDA analysis.
pg_lda <- cbind(pg_labels, pgsc_trait)


## LDA
pglda <- lda(Species ~ Anthocyanins + LMA  + Thickness + Toughness + Shannon,
            data = pg_lda, method = "moment")


#Model predictions into list
pglda.values <- predict(pglda)

#Model scores
pglda$scores <- predict(pglda)$x

#coef(ld2a) and ld2a$scaling is the same.

#Extraction of model coefficients 
pgld2b <- data.frame(varnames = rownames(coef(pglda)), coef(pglda))
pgld2b$length <- with(pgld2b, sqrt(LD1^2+LD2^2))
# scaling <- data.frame(ld2a$scaling) #Another way of extracting model coefficients.
# scaling <- scaling %>%
#   rownames_to_column(var = "varnames") %>%
#   mutate(length = sqrt(LD1^2+LD2^2))


#only the x variables from predict
pgldax <- as.data.frame(pglda.values$x)
row.names(pgldax)

#Write the predicted values for each samples as a table.
LDPGtraits <- cbind(pg_lda,pgldax)
LDPGtraits # Use for ggplots


#labels<-data.frame(factor)
#labels

#Model accuracy
mean(LDPGtraits$Species == pglda.values$class)

xtabs(~LDPGtraits$Species + pglda.values$class)

#The model is 95.3% accurate is discriminating species groups.

#Discriminant axes percent variance explained
prop.pg = pglda$svd^2/sum(pglda$svd^2)

pgldaplot <- ggplot(LDPGtraits, aes(LD1, LD2)) +
  geom_point(data = LDPGtraits, aes(color = Species, shape = E_load), size = rel(3), alpha = 0.7) +
  stat_ellipse(aes(color = Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1,
               level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
    geom_hline(aes(yintercept=0), size=.2) + geom_vline(aes(xintercept=0), size=.2) +
    geom_segment(data = pgld2b,
                      aes(x=0, y=0,
                          xend = LD1, yend = LD2,
                          shape = NULL, linetype = NULL,
                          alpha = length),
                      arrow = arrow(length=unit(0.2,"cm")),
                      color ="red") +
    geom_text(data = pgld2b,
                   aes(x=LD1*0.75, y=LD2*0.75,
                       label = varnames, 
                       shape = NULL, linetype = NULL,
                       alpha = length),
                   size = 3, vjust = 0.5,
                   hjust = 0, color = "black") +
    labs(x = paste("LD1 (", round(prop.lda[1]*100, digits = 1), "%)", sep="")) +
    labs(title = "Pathogen LDA: E-+, leaf traits and Shanno diversity", caption = "(95% accuracy)", y = paste("LD2 (", round(prop.lda[2]*100, digits = 1), "%)", sep="")) +  
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
   theme(
plot.title = element_text(color="red", size=14, face="bold"))

pgldaplot

#ggsave(filename = "Plots/Path_LDAfull_02282023.png", plot = pgldaplot, dpi=600, units=c("mm"), width=300, height=300)

```

```{r, LDA model with interactions, tidy = TRUE}
# LDA with interactions #############

ld2c <- lda(Species ~ Anthocyanins * LMA  * Thickness * Toughness * E_load * Shannon * Total_leaf_area_cut,
            data = ant_lda, method="moment")

#Model predictions into list
ldac.values <- predict(ld2c)

#Model scores
ld2c$scores <- predict(ld2c)$x

#coef(ld2a) and ld2a$scaling is the same.

#Extraction of model coefficients 
ld2d <- data.frame(varnames = rownames(coef(ld2c)), coef(ld2c))

ld2d$length <- with(ld2d, sqrt(LD1^2+LD2^2))

#only the x variables from predict
ldacx <- as.data.frame(ldac.values$x)
row.names(ldacx)

#Write the predicted values for each samples as a table.
LDCtraits <- cbind(ant_lda,ldacx)
LDCtraits # Use for ggplots

row.names(ld2c$scaling)
#labels<-data.frame(factor)
#labels

#Model accuracy
mean(LDCtraits$Species == ldac.values$class)

xtabs(~LDCtraits$Species + ldac.values$class)

#The model is 100% accurate is discriminating species groups.

#Discriminant axes percent variance explained
prop.ldac = ld2c$svd^2/sum(ld2c$svd^2)

#LDA full model plot with ggplot

ldainter <- ggplot(LDCtraits, aes(LD1, LD2)) +
  geom_point(data = LDCtraits, aes(color = Species, shape = E_load), size = rel(3), alpha = 0.7) +
  stat_ellipse(aes(color = Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1,
               level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
    geom_hline(aes(yintercept=0), size=.2) + geom_vline(aes(xintercept=0), size=.2) +
    geom_segment(data = ld2d,
                      aes(x=0, y=0,
                          xend = LD1, yend = LD2,
                          shape = NULL, linetype = NULL,
                          alpha = length),
                      arrow = arrow(length=unit(0.2,"cm")),
                      color ="red") +
    geom_text(data = ld2b,
                   aes(x=LD1*0.75, y=LD2*0.75,
                       label = varnames, 
                       shape = NULL, linetype = NULL,
                       alpha = length),
                   size = 3, vjust = 0.5,
                   hjust = 0, color = "black") +
    labs(x = paste("LD1 (", round(prop.ldac[1]*100, digits = 1), "%)", sep="")) +
    labs(title = "Full model LDA with interactions", caption = "100% accuracy", y = paste("LD2 (", round(prop.ldac[2]*100, digits = 1), "%)", sep="")) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  theme(
plot.title = element_text(color="red", size=14, face="bold.italic"))

ldainter

#ggsave(filename = "LDAinter.png", plot = ldainter, dpi=600, units=c("mm"), width=300, height=300)
```

Modelling the interaction does achieve 100% accuracy but it is harder to interpret. The plot for model with interaction terms is harder to interpret. The arrow labels over lap and are not readable.

### LDA: E+ models

The objective here is to model what leaf traits are important for discriminating between groups with differing endophyte loads. Focusing on the endophyte load allows us to understand if E+ and E- are distinguishable.  
```{r, Ant E_load models, tidy = TRUE}
### Data prep ###
### subset for E+ samples
ant_Elab <- masterant %>%
  filter(E_load == "E+")

e_labs <- ant_Elab[,1:4]
e_std <- ant_Elab[,6:15]

#Scaling
esc_trait <- scale(e_std, center = TRUE, scale = TRUE)

#Creating a new data set that is ready from downstream LDA analysis.
e_lda <- cbind(e_labs, esc_trait)

lde <- lda(Species ~ Anthocyanins + LMA  + Thickness + Toughness + Shannon,
            data = e_lda, method = "moment")

#Model predictions into list
lde.values <- predict(lde)

#Model scores
lde$scores <- predict(lde)$x

#coef(ld2a) and ld2a$scaling is the same.

#Extraction of model coefficients 
ld2e <- data.frame(varnames = rownames(coef(lde)), coef(lde))

ld2e$length <- with(ld2e, sqrt(LD1^2+LD2^2))

#only the x variables from predict
ldex <- as.data.frame(lde.values$x)
row.names(ldex)

#Write the predicted values for each samples as a table.
LDEtraits <- cbind(e_lda,ldex)
LDEtraits # Use for ggplots and linear mixed models

row.names(ld2e$scaling)
#labels<-data.frame(factor)
#labels

#Model accuracy
mean(LDEtraits$Species == lde.values$class)

xtabs(~LDEtraits$Species + lde.values$class)

#The model is 97% accurate is discriminating species groups.

#Discriminant axes percent variance explained
prop.lde = lde$svd^2/sum(lde$svd^2)

#LDA E+ full model plot with ggplot
ldee <- ggplot(LDEtraits, aes(LD1, LD2)) +
  geom_point(data = LDEtraits, aes(color = Species), size = rel(3), alpha = 0.7) +
  stat_ellipse(aes(color = Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1,
               level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
    geom_hline(aes(yintercept=0), size=.2) + geom_vline(aes(xintercept=0), size=.2) +
    geom_segment(data = ld2e,
                      aes(x=0, y=0,
                          xend = LD1, yend = LD2,
                          shape = NULL, linetype = NULL,
                          alpha = length),
                      arrow = arrow(length=unit(0.2,"cm")),
                      color ="red") +
    geom_text(data = ld2e,
                   aes(x=LD1*0.75, y=LD2*0.75,
                       label = varnames, 
                       shape = NULL, linetype = NULL,
                       alpha = length),
                   size = 3, vjust = 0.5,
                   hjust = 0, color = "black") +
    labs(x = paste("LD1 (", round(prop.lde[1]*100, digits = 1), "%)", sep="")) +
    labs(title = "Ant E+ LDA: leaf traits and Shannon diversity", caption = "(97% accuracy)", y = paste("LD2 (", round(prop.lde[2]*100, digits = 1), "%)", sep="")) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
   theme(
plot.title = element_text(color="red", size=14, face="bold"))

ldee


#ggsave(filename = "Plots/Ant_LDA_Eplus02282023.png", plot = ldee, dpi=600, units=c("mm"), width=300, height=300)
```

The November 2022 iteration of this plot had similar values for LD1 and LD2. What is different now (02282023) is how the traits are "driving" the discrimination of the groups. Leaf toughness, thickness and LMA are in the upper half of the plot, opposite to anthocyanins in LD2. Additionally, leaf toughness and thickness align opposite to each other in LD1. Shannon diversity does not seam to be important for distinguishing the groups.

```{r, Pathogen E_load models, tidy = TRUE}
### Data prep ###
### subset for E+ samples
pat_Elab <- masterpat %>%
  filter(E_load == "E+")

pe_labs <- pat_Elab[,1:6]
pe_std <- pat_Elab[,7:16]

#Scaling
psc_trait <- scale(pe_std, center = TRUE, scale = TRUE)

#Creating a new data set that is ready from downstream LDA analysis.
pe_lda <- cbind(pe_labs, psc_trait)

ldep <- lda(Species ~ Anthocyanins + LMA  + Thickness + Toughness + Shannon,
            data = pe_lda, method="moment")

#Model predictions into list
ldep.values <- predict(ldep)

#Model scores
ldep$scores <- predict(ldep)$x

#coef(ld2a) and ld2a$scaling is the same.

#Extraction of model coefficients 
ld2ep <- data.frame(varnames = rownames(coef(ldep)), coef(ldep))
ld2ep$length <- with(ld2ep, sqrt(LD1^2+LD2^2))

#only the x variables from predict
ldepx <- as.data.frame(ldep.values$x)
row.names(ldepx)

#Write the predicted values for each samples as a table.
LDEPtraits <- cbind(pe_lda,ldepx)
LDEPtraits # Use for ggplots and linear mixed models

#labels<-data.frame(factor)
#labels

#Model accuracy
mean(LDEPtraits$Species == ldep.values$class)

xtabs(~LDEPtraits$Species + ldep.values$class)

#The model is 100% accurate is discriminating species groups.

#Discriminant axes percent variance explained
prop.ldep = ldep$svd^2/sum(ldep$svd^2)

#LDA E+ full model plot with ggplot
ldeep <- ggplot(LDEPtraits, aes(LD1, LD2)) +
  geom_point(data = LDEPtraits, aes(color = Species), size = rel(3), alpha = 0.7) +
  stat_ellipse(aes(color = Species), geom = "path", size = 1.3, position = "identity", type = "t", linetype = 1,
               level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) +
    geom_hline(aes(yintercept=0), size=.2) + geom_vline(aes(xintercept=0), size=.2) +
    geom_segment(data = ld2ep,
                      aes(x=0, y=0,
                          xend = LD1, yend = LD2,
                          shape = NULL, linetype = NULL,
                          alpha = length),
                      arrow = arrow(length=unit(0.2,"cm")),
                      color ="red") +
    geom_text(data = ld2ep,
                   aes(x=LD1*0.75, y=LD2*0.75,
                       label = varnames, 
                       shape = NULL, linetype = NULL,
                       alpha = length),
                   size = 3, vjust = 0.5,
                   hjust = 0, color = "black") +
    labs(x = paste("LD1 (", round(prop.ldep[1]*100, digits = 1), "%)", sep="")) +
    labs(title = "Pathogen E+ LDA: leaf traits and Shannon diversity", caption = "(100% accuracy)", y = paste("LD2 (", round(prop.ldep[2]*100, digits = 1), "%)", sep="")) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
   theme(
plot.title = element_text(color="red", size=14, face="bold"))

ldeep  

# ggsave(filename = "Plots/Path_LDA_Eplus_02282023.png", plot = ldeep, dpi=600, units=c("mm"), width=300, height=300)

```

Again, very similar to previous results. Looking closely at the plots from 11/2022 I see that some of the were calculated with Shannon diversity. This explain why the results are so similar or the same. BAR-02282023

# LDA: simple linear regression models

We have reduced the number of leaf traits by computing an LDA for ant and pathogen trials. This reduced the number of covariates to two synthetic ones that explain the most variance in the model: LD1 and LD2. Now, we proceed to compute simple linear regressions with LD1 and LD2 as the fixed effects for the models, while adding biological trait measurements (i.e. Shannon diversity).

The LD's from data frames `LDtraits` and `LDPGtraits` are computed with all the data points (i.e. E+ and E- samples) for each trial type. The LD's from data frames `LDEtraits` and `LDEPtraits` are computed with the E+ samples.

### Ant

```{r, Ant LDA regression, tidy = FALSE}
# Use LDA loadings to model effects ant herbivory

# Null model
lm1 <- lm(Total_leaf_area_cut ~ 1, data = LDEtraits)
summary(lm1)
#plot(lm1)

plot_model(lm1, type = "diag")

# Model 1 
lm2 <- lm(Total_leaf_area_cut ~ LD1 + LD2, data = LDEtraits)
summary(lm2)
# # Residuals
# lm2_resid <- resid(lm2, type = "response")
# lm2_fitted <- fitted(lm2)
# #Histograms
# hist(lm2_resid)
# hist(lm2_fitted)

#lm2 model plot
plot_model(lm2, type = "diag")
AIC(lm2) #106.7782 This is slightly higher than lm1.

# Model comparison
anova(lm1, lm2)

#step(lm2, direction = "both") #Warning: attempting model selection on an essentially perfect fit is nonsense
############
ant_ld1reg <- ggplot(LDEtraits, aes(LD1, Total_leaf_area_cut)) +
  geom_jitter(aes(color = Species), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  labs(title = "Herbivory by leaf cutter ants vs. LD1", y = "Total leaf area cut", caption = "LD1 explains the most variance in LDA model.") +
  theme(plot.title = element_text(color="red", size = 14, face="bold.italic"))
  
ant_ld1reg

#ggsave(filename = "Ant_LD1_Reg.png", plot = ant_ld1reg, dpi=600, units=c("mm"), width=300, height=300)
#
#LD2
ant_ldareg <- ggplot(LDEtraits, aes(LD2, Total_leaf_area_cut)) +
  geom_jitter(aes(color = Species), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  labs(title = "Herbivory by leaf cutter ants vs. LD2", y = "Total leaf area cut", caption = "LD2 is the most significant predictor in LMM.") +
  theme(plot.title = element_text(color="red", size = 14, face="bold.italic"))
  
ant_ldareg

#ggsave(filename = "Ant_LD2_Reg.png", plot = ant_ldareg, dpi=600, units=c("mm"), width=300, height=300)
#
#Shannon Diversity

ant_ldashannon <- ggplot(LDEtraits, aes(Shannon, Total_leaf_area_cut)) +
  geom_jitter(aes(color = Species), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  labs(title = "Herbivory by leaf cutter ants vs. Shannon diversity", y = "Total leaf area cut") +
  theme(plot.title = element_text(color="red", size = 14, face="bold.italic"))

ant_ldashannon

#ggsave(filename = "Ant_LDA_shannon.png", plot = ant_ldashannon, dpi=600, units=c("mm"), width=300, height=300)

```

### Pathogen

```{r}
# Use LDA loadings to model effects ant herbivory

# Null model
pm1 <- lm(Pathogen_Damage_area~ 1, data = LDEPtraits)
summary(pm1)
#plot(pm1)
plot_model(pm1, type = "diag")

# Model 1 
pm2 <- lm(Pathogen_Damage_area ~ LD1 + LD2 + Shannon, data = LDEPtraits)
summary(pm2)
# # Residuals
# lm2_resid <- resid(lm2, type = "response")
# lm2_fitted <- fitted(lm2)
# #Histograms
# hist(lm2_resid)
# hist(lm2_fitted)

#lm2 model plot
plot_model(pm2, type = "diag")
AIC(pm2)

# Model comparison
anova(pm1, pm2)

#step(pm2, direction = "both") #Warning: attempting model selection on an essentially perfect fit is nonsense
############
#LD1
pat_ld1reg <- ggplot(LDEPtraits, aes(LD1, Pathogen_Damage_area)) +
  geom_jitter(aes(color = Species), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  labs(title = "Pathogen Leaf Damage vs. LD1", y = "Total pathogen damaged area", caption = "LD1 explains the most variance in the LDA model") +
  theme(plot.title = element_text(color="red", size=14, face="bold.italic"))
  
pat_ld1reg

#ggsave(filename = "Pat_LD1_Reg.png", plot = pat_ld1reg, dpi=600, units=c("mm"), width=300, height=300)
#
#LD2
pat_ld2reg <- ggplot(LDEPtraits, aes(LD2, Pathogen_Damage_area)) +
  geom_jitter(aes(color = Species), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  labs(title = "Pathogen Leaf Damage vs. LD2", y = "Total pathogen damaged area") +
  theme(plot.title = element_text(color="red", size=14, face="bold.italic"))
  
pat_ld2reg

#ggsave(filename = "Pat_LD2_Reg.png", plot = pat_ld2reg, dpi=600, units=c("mm"), width=300, height=300)
#
#Shannon diversity

pat_lda_shannon <- ggplot(LDEPtraits, aes(Shannon, Pathogen_Damage_area)) +
  geom_jitter(aes(color = Species), size = 3, alpha = 0.7) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black", size = 0.5) +
  stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  #stat_regline_equation(label.y.npc = "top", label.x.npc = "center", aes(label = ..eq.label..), color= "black", size = 2.2) +
  scale_color_manual(values = met.brewer(name = "Cross", n = 8, type="discrete")) +
  labs(title = "Pathogen Leaf Damage vs. Shannon diversity", y = "Total pathogen damaged area") +
  theme(plot.title = element_text(color="red", size=14, face="bold.italic"))
  
pat_lda_shannon

#ggsave(filename = "Pat_LDA_shannon.png", plot = pat_lda_shannon, dpi=600, units=c("mm"), width=300, height=300)
```

# LDA: Linear Mixed Models

In the section above, we see that the diagnostics plots for simple linear regressions with the ant and pathogen data have a fair amount of heteroskedasticity. Meaning, there is an un-even or non-random distribution of the residuals. They resemble more a triangle or fan-like distribution. In this section, I attempt to optimize by changing the estimation methos and applying optimizers to the distribution of the residuals with generalized linear mixed models (e.g. `bobyqa`)or linear mixed effects models (e.g. `nlminb`) .

Initial models with `nlme` package use "Maximum Likelihood", then "REML" and `Species` or `E_load` as random effects.

## Ants
### ML-ants
```{r, Ant Maximum Likelihood model selection, tidy = TRUE}
#nlme package
#Model1
aglm <- lme(Total_leaf_area_cut ~ LD1 + LD2, random = ~1|Species, method = "ML", data = LDEtraits)

summary(aglm)
AIC(aglm) # 108.5
plot_model(aglm, type = "diag")

#Model2
aglm2 <- lme(Total_leaf_area_cut ~ LD1 + LD2, random = ~1|Species/E_load, method = "ML", data = LDEtraits)

summary(aglm2)
AIC(aglm2) #110.5
plot_model(aglm2, type = "diag")

#Model3 interactions
aglm3 <- lme(Total_leaf_area_cut ~ LD1 * LD2, random = ~1|Species/E_load, method = "ML", data = LDEtraits)

summary(aglm3)
AIC(aglm3) #111.5
plot_model(aglm3, type = "diag")


tab_model(aglm, aglm2, aglm3, show.re.var = T, show.aic = TRUE, show.intercept = TRUE, title = "LMM Maximum Likelihood Ant damage", CSS = list(
    css.depvarhead = 'font-weight:bold;',
    css.centeralign = 'text-align: left;', 
    css.firsttablecol = 'font-weight: bold;',
    css.summary = 'color: blue; font-weight: bold;',
     dv.labels = c("aglm ", "aglm2", "aglm3"),
    p.style = "numeric_stars"))
```

```{r, Ant Model validation, tidy = TRUE}
aglm_resid <- resid(aglm, type = "response")
aglm_fitted <- fitted(aglm)

plot(aglm_resid)
plot(aglm_fitted)

# Visual Model Validation

op <- par(mfrow = c(2, 2), mar = c(4, 4, 2, 2))
plot(LDEtraits$LD1, jitter(resid(aglm, type = "response")), xlab = "LD1", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$LD2, jitter(resid(aglm, type = "response")), xlab = "LD2", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$Shannon, jitter(resid(aglm, type = "response")), xlab = "Shannon", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
```

### REML-ants
```{r, Ant Restricted Maximum Likelihood models, tidy = TRUE}
#  < - glmer(Total_leaf_area_cut ~ LD1 + LD2 + Shannon + (1| Species) + (1| E_load), data = LDEtraits, family = "poisson", control = glmerControl(optimizer="bobyqa"))

areml <- lme(Total_leaf_area_cut ~ LD1 + LD2, random = ~1|Species, method = "REML", data = LDEtraits) 

summary(areml)
AIC(areml) #118.6
plot_model(areml, type = "diag")

tab_model(aglm, areml, show.re.var = T, show.aic = TRUE, show.intercept = TRUE, title = "LMM Maximum Likelihood Ant damage", CSS = list(
    css.depvarhead = 'font-weight:bold;',
    css.centeralign = 'text-align: left;', 
    css.firsttablecol = 'font-weight: bold;',
    css.summary = 'font-weight: bold;',
    dv.labels = c("aglm ", "areml"),
    p.style = "numeric_stars"))


```

Model estimation with REML increases AIC. Proceeding with ML model estimation. 


### Random effects-ants
```{r, Checking contribution of random effects-ants, tidy = TRUE}

agls <- gls(Total_leaf_area_cut ~ LD1 + LD2, method = "ML", data = LDEtraits)

AIC(aglm, agls)
anova(aglm, agls)
#  

```

Species as a random effect increases AIC value by two points. Not that much, and it is worth keeping because it's biological relevance  to the questions.

### ML-2-ants

Continuation of previous ML section. Modelling variance structure with `varIdent`, `varExp` and `varComb`.
```{r, Ant Modelling Variance Structure}
#varIdent
aglm_ident <- lme(Total_leaf_area_cut ~ LD1 + LD2, random = ~1|Species, method = "ML", weights = varIdent(form = ~ 1|Species), control =  lmeControl(opt= 'nlminb'),  data = LDEtraits)

AIC(aglm_ident) #AIC  = 97
summary(aglm_ident)
Anova(aglm_ident, type = "III")

plot_model(aglm_ident, type= "diag")

#Modelling variance structure with varIdent returns a lower AIC value (97.08464)
#

# Model validation
op <- par(mfrow = c(3, 2), mar = c(4, 4, 2, 2))
plot(LDEtraits$LD1, jitter(resid(aglm_ident, type = "response")), xlab = "LD1", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$LD1, jitter(resid(aglm_ident, type = "normalized")), xlab = "LD1", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$LD2, jitter(resid(aglm_ident, type = "response")), xlab = "LD2", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$LD2, jitter(resid(aglm_ident, type = "normalized")), xlab = "LD2", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$Shannon, jitter(resid(aglm_ident, type = "response")), xlab = "Shannon", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$Shannon, jitter(resid(aglm_ident, type = "normalized")), xlab = "Shannon", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")

#
par(mfrow = c(1,2))
plot(fitted(aglm_ident), resid(aglm_ident, type="normalized"), cex.axis=.5,
cex=.4, xlab="fitted values", ylab="standardized resid", cex.lab=.8)
plot(LDEtraits$Species, resid(aglm_ident, type="normalized"), cex.axis=.5,
cex=.4, xlab="Species", ylab="standardized resid", cex.lab=.8)
abline(h = 0, col = "blue")
```

```{r, Ant varExp, tidy = TRUE}
# varExp

# aglm_exp <- lme(Total_leaf_area_cut ~ LD1 + LD2, random = ~1|Species, method = "ML", weights = varExp(form = ~ LD1), control =  lmeControl(opt= 'nlminb'),  data = LDEtraits)
# 
#AIC(aglm_exp) #AIC = 107.98

```

```{r, Ant varComb, tidy = TRUE}
# varComb

 aglm_comb <- lme(Total_leaf_area_cut ~ LD1 + LD2, random = ~1|Species, method = "ML", weights = varComb(varIdent(form = ~ 1|Species), varPower()), control = lmeControl(opt = 'nlminb'),  data = LDEtraits) # Model is not converging as of 02/28/2023
# The model above was not converging because I modeled with a fixed factor (Shannon) that was already reduced with the LDA. It makes it hard converge or there i no convergence at all because of the colinearity it causes (If I remember correctly). -BAR 03/02/2023
# 
# control = lmeControl(msMaxIter = 1000, msMaxEval = 1000)

AIC(aglm_comb) #Lowest AIC yet! 94.85672
summary(aglm_comb)
Anova(aglm_comb, type = "III")
# plot_model(aglm_comb, type = "diag")
# #anova(M1,type="marginal") #What is a type III ANOVA?


#Model Validation
op <- par(mfrow = c(3, 2), mar = c(4, 4, 2, 2))
plot(LDEtraits$LD1, jitter(resid(aglm_comb, type = "response")), xlab = "LD1", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$LD1, jitter(resid(aglm_comb, type = "normalized")), xlab = "LD1", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$LD2, jitter(resid(aglm_comb, type = "response")), xlab = "LD2", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$LD2, jitter(resid(aglm_comb, type = "normalized")), xlab = "LD2", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$Shannon, jitter(resid(aglm_comb, type = "response")), xlab = "Shannon", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$Shannon, jitter(resid(aglm_comb, type = "normalized")), xlab = "Shannon", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")


#
par(mfrow = c(1,2))
plot(fitted(aglm_comb), resid(aglm_comb, type="normalized"), cex.axis=.5,
cex=.4, xlab="fitted values", ylab="standardized resid", cex.lab=.8)
abline(h = 0, col = "blue")

plot(LDEtraits$Species, resid(aglm_comb, type="normalized"), cex.axis=.5,
cex=.4, xlab="Species", ylab="standardized resid", cex.lab=.8)
abline(h = 0, col = "blue")

```

The model above was not converging because I modeled with a fixed factor (Shannon) that was already reduced with the LDA. It makes it hard converge or there i no convergence at all because of the colinearity it causes (If I remember correctly). -BAR 03/02/2023

```{r, Table comparing Ant linear models, tidy = TRUE}
# Initial model with out variance structure, `varIdent` structure, and `varComb`

tab_model(aglm, aglm_ident, aglm_comb,
          transform = NULL,
          show.est = TRUE,
          show.se = TRUE,
          auto.label = TRUE,
          show.re.var = T, 
          show.aic = TRUE, 
          show.intercept = TRUE, 
          title = "LMM Maximum Likelihood Ant damage",
          # pred.labels = c("Intercept"),
          dv.labels = c("aglm ", "aglm_ident", "aglm_comb"),
          string.pred = "Coefficient",
          string.ci = "CI (95%)",
          string.p = "P-Value",
          digits.p = 3, 
          p.style = c("numeric_stars"))


    # css.depvarhead = 'font-weight:bold;',
    # css.centeralign = 'text-align: left;', 
    # css.firsttablecol = 'font-weight: bold;',
    # css.summary = 'color: black;',
    # p.style = "numeric_stars"))
```

#### Notes on model building with LDA axes

Optimizers: `lmeControl` uses `nlminb` as the default optimizer. Unconstrained and box-constrained optimization using PORT routines.
`varIdent` is used to model variance structure because I believe variance varies across tree species (categories).

Variance structure: I explored further, variance modelling with `varComb`. This resulted in the lowest AIC value of all the models. Potentially I can model these interactions with `glmer`. Now, I have to decide if I want to use "generalized" linear mixed effects models or "linear" mixed effects models. I am uncertain of how GLMM's handle variance structure more than just including the random effects. 

I tried nesting E_load in Species as a random effect but it increases AIC value (~100). It is not a big change. Potentially worth including. 

Repeat process with pathogen data set.

## Pathogen
### ML-pathogen
```{r, Pathogen Maximum Likelihood model selection, tidy = TRUE}
#nlme package

#Model1
pglm <- lme(Pathogen_Damage_area ~ LD1 + LD2, random = ~1|Species, method = "ML", data = LDEPtraits)
summary(pglm)
anova(pglm)

AIC(pglm) # 182.26
plot_model(pglm, type = "diag")


# Visual Model Validation

pglm_resid <- resid(pglm, type = "response")
pglm_fitted <- fitted(pglm)

plot(pglm_resid)
plot(pglm_fitted)

op <- par(mfrow = c(2, 2), mar = c(4, 4, 2, 2))
plot(LDEPtraits$LD1, jitter(resid(pglm, type = "response")), xlab = "LD1", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$LD2, jitter(resid(pglm, type = "response")), xlab = "LD2", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$Shannon, jitter(resid(pglm, type = "response")), xlab = "Shannon", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")


#Model2
pglm2 <- lme(Pathogen_Damage_area  ~ LD1 + LD2, random = ~1|Species/E_load, method = "ML", data = LDEPtraits)

summary(pglm2)
AIC(pglm2) #184.26
plot_model(pglm2, type = "diag")


#Model3 interactions
pglm3 <- lme(Pathogen_Damage_area ~ LD1 * LD2 , random = ~1|Species/E_load, method = "ML", data = LDEPtraits)

summary(pglm3)
AIC(pglm3) #191.52
plot_model(pglm3, type = "diag")


tab_model(pglm, pglm2, pglm3,
          transform = NULL,
          show.est = TRUE,
          show.se = TRUE,
          auto.label = TRUE,
          show.re.var = T, 
          show.aic = TRUE, 
          show.intercept = TRUE, 
          title = "LMM Maximum Likelihood Pathogen damage",
          # pred.labels = c("Intercept"),
          dv.labels = c("pglm ", "pglm2", "pglm3"),
          string.pred = "Coefficient",
          string.ci = "CI (95%)",
          string.p = "P-Value",
          digits.p = 3, 
          p.style = c("numeric_stars"))
```

### REML-pathogen

```{r, Restricted Maximum Likelihood Models, tidy = TRUE }
preml <- lme(Pathogen_Damage_area ~ LD1 + LD2, random = ~1|Species, method = "REML", data = LDEPtraits) 

summary(preml)
AIC(preml) #192.42
plot_model(preml, type = "diag")

tab_model(pglm, preml, show.re.var = T, show.aic = TRUE, show.intercept = TRUE, title = "LMM Maximum Likelihood Ant damage", CSS = list(
    css.depvarhead = 'font-weight:bold;',
    css.centeralign = 'text-align: left;', 
    css.firsttablecol = 'font-weight: bold;',
    css.summary = 'font-weight: bold;',
    dv.labels = c("pglm ", "preml"),
    p.style = "numeric_stars"))


```

Model estimation with REML increases slightly AIC. Proceeding with ML model estimation. 

### Random effects-pathogen

```{r, Checking contribution of random effects-pathogen, tidy = TRUE}

pgls <- gls(Pathogen_Damage_area ~ LD1 + LD2, method = "ML", data = LDEPtraits)

AIC(pglm, pgls)
anova(aglm, agls)
# Species as a random factor decreases AIC value by ~0.5 points.

```

### ML-2-pathogen

Continuation of previous ML section. Moelling variance structure with `varIdent`, `varExp` and `varComb`.
The pathogen data set has various nested factors. We have Species with different endophyte load (-+) then each of those individuals had a leaf that served as a control and another that was exposed to the pathogen. Hence, modelling for this data set is slightly different than the Ant data set.
```{r, Pathogen Modelling Variance Structure, tidy = TRUE}
#varIdent
pglm_ident <- lme(Pathogen_Damage_area ~ LD1 + LD2, random = ~1|Species/Treatment, method = "ML", weights = varIdent(form = ~ 1|Species), control =  lmeControl(opt= 'nlminb'),  data = LDEPtraits)

summary(pglm_ident)
AIC(pglm_ident) #132.2
Anova(pglm_ident, type = "III")
plot_model(pglm_ident, type= "diag")

#Modelling variance structure with varIdent returns a lower AIC value (132)


# Model validation
op <- par(mfrow = c(3, 2), mar = c(4, 4, 2, 2))
plot(LDEPtraits$LD1, jitter(resid(pglm_ident, type = "response")), xlab = "LD1", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$LD1, jitter(resid(pglm_ident, type = "normalized")), xlab = "LD1", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$LD2, jitter(resid(pglm_ident, type = "response")), xlab = "LD2", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$LD2, jitter(resid(pglm_ident, type = "normalized")), xlab = "LD2", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEtraits$Shannon, jitter(resid(aglm_ident, type = "response")), xlab = "Shannon", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$Shannon, jitter(resid(pglm_ident, type = "normalized")), xlab = "Shannon", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")

#
par(mfrow = c(1,2))
plot(fitted(pglm_ident), resid(pglm_ident, type="normalized"), cex.axis=.5,
cex=.4, xlab="fitted values", ylab="standardized resid", cex.lab=.8)
plot(LDEPtraits$Species, resid(pglm_ident, type="normalized"), cex.axis=.5,
cex=.4, xlab="Species", ylab="standardized resid", cex.lab=.8)
abline(h = 0, col = "blue")
```

```{r, Pathogen varExp, tidy = TRUE}
# varExp

pglm_exp <- lme(Pathogen_Damage_area ~ LD1 + LD2, random = ~1|Species/Treatment, method = "ML", weights = varExp(form = ~ LD1|Species), control = lmeControl(msMaxIter = 100, msMaxEval = 100),  data = LDEPtraits)
#control = lmeControl(msMaxIter = 1000, msMaxEval = 1000)
summary(pglm_exp)
AIC(pglm_exp)#162
Anova(pglm_exp, type = "III")
plot_model(pglm_exp, type= "diag")
```

```{r, Pathogen varComb, tidy = TRUE}
# varComb
pglm_comb <- lme(Pathogen_Damage_area ~ LD1 + LD2, random = ~1|Species/Treatment, method = "ML", weights = varComb(varIdent(form = ~ 1 | Species), varPower()), control =  lmeControl(opt = 'nlminb'), data = LDEPtraits) # No convergence -03/03/2023. As of 03/06/2023 the model "reached without convergence". The argument 'returnObject' inside lmeControl is set to TRUE, allowing for this. 

# Optimizer control code. 
#control = lmeControl(msMaxIter = 5000, msMaxEval = 5000, msTol = 1e-7, returnObject = TRUE),
# control =  lmeControl(opt= 'nlminb')

summary(pglm_comb)
Anova(pglm_comb, type = 3)
AIC(pglm_comb) #128.2
plot_model(pglm_comb, type = "diag")

#Model Validation
op <- par(mfrow = c(3, 2), mar = c(4, 4, 2, 2))
plot(LDEPtraits$LD1, jitter(resid(pglm_comb, type = "response")), xlab = "LD1", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$LD1, jitter(resid(pglm_comb, type = "normalized")), xlab = "LD1", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$LD2, jitter(resid(pglm_comb, type = "response")), xlab = "LD2", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$LD2, jitter(resid(pglm_comb, type = "normalized")), xlab = "LD2", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$Shannon, jitter(resid(pglm_comb, type = "response")), xlab = "Shannon", ylab = "Ordinary Residuals")
abline(h = 0, col = "blue")
plot(LDEPtraits$Shannon, jitter(resid(pglm_comb, type = "normalized")), xlab = "Shannon", ylab = "Norm/standarized Residuals")
abline(h = 0, col = "blue")


#
par(mfrow = c(1,2))
plot(fitted(pglm_comb), resid(pglm_comb, type="normalized"), cex.axis=.5,
cex=.4, xlab="fitted values", ylab="standardized resid", cex.lab=.8)
abline(h = 0, col = "blue")
plot(LDEPtraits$Species, resid(pglm_comb, type="normalized"), cex.axis=.5,
cex=.4, xlab="Species", ylab="standardized resid", cex.lab=.8)
abline(h = 0, col = "blue")
```

```{r, Pathogen Table comparing linear models, tidy = TRUE}

# Initial model with out variance structure, "varIdent" structure, and "varComb" structure

tab_model(pglm, pglm_ident, pglm_exp, pglm_comb,
          transform = NULL,
          show.est = TRUE,
          show.se = TRUE,
          auto.label = TRUE,
          show.re.var = T, 
          show.aic = TRUE, 
          show.intercept = TRUE, 
          title = "LMM Maximum Likelihood Pathogen damage",
          # pred.labels = c("Intercept"),
          dv.labels = c("pglm ", "pglm_ident", "pglm_exp", "pglm_comb"),
          string.pred = "Coefficient",
          string.ci = "CI (95%)",
          string.p = "P-Value",
          digits.p = 3, 
          p.style = c("numeric_stars"))


    # css.depvarhead = 'font-weight:bold;',
    # css.centeralign = 'text-align: left;', 
    # css.firsttablecol = 'font-weight: bold;',
    # css.summary = 'color: black;',
    # p.style = "numeric_stars"))
```

# LMM tables and estimate plots for ant and pathogen models

```{r, Tables comparing LMM models, tidy = TRUE}

#This just merges tables made for Ant models and Pathogen models computed in previous sections. 
#
tab_model(aglm_comb, pglm_comb,
          transform = NULL,
          show.est = TRUE,
          show.se = TRUE,
          auto.label = TRUE,
          show.re.var = T,
          show.aic = TRUE,
          show.intercept = TRUE,
          title = "Best-fit LMM's Ant and Pathogen damage",
          pred.labels = c("Intercept", "LD1", "LD2"),
          dv.labels = c("Ant herbivory", "Pathogen damage"),
          string.pred = "Coefficient",
          string.ci = "CI (95%)",
          string.p = "P-Value",
          digits.p = 3,
          p.style = c("numeric_stars"))# file = "H:/.shortcut-targets-by-id/0B9v0CdUUCqU5VVR4a3BvNHM1Z28/VBL_users/Grad_Students/Bolivar/Dissertation/Leaf_Traits_Panama/Data/Sample_Sequencing/Post_Sequencing/Sequence_analyses/Reports/BestFit_LMM_Aant_Pathogen_02152023.html")

```



# Indicator species analysis

This analysis allows us to determine what endophytes are associated with particular groups (e.g. tree species). According to this vgnette from Cáceres ([2022](https://cran.r-project.org/web/packages/indicspecies/vignettes/IndicatorSpeciesAnalysis.html)) `multipatt` function can provides us with Indicators Value Index and correlation index. Both are similar, but the differences lies in the question they help answer. Indicator value index "[...]are used for assessing the predictive values of species as indicators of the conditions prevailing in site groups, e.g. for field determination of community types or ecological monitoring." While the correlation index can be used for "[...] determining the ecological preferences of species among a set of alternative site groups or site group combinations."

Given this, it will be best to compute a correlation index. This will allow to determine what endophytes are correlated with particular tree species or across treatment types (E-+).

```{r, Indicator species, tidy = TRUE}

#Subset data frame for indicator species analysis
#Community Data
cotu <- left_join(cOTU, ndata2, by = "Sample_name") %>%
  select(!c(Trial_type, 
            Trial_Code, 
            Anthocyanins, 
            Thickness,
            Toughness, 
            LMA)) %>%
  relocate(Species, E_load, .after = Sample_name)
```


```{r}
#Making vector of groups for analysis
indiabun <- cotu[, 4:ncol(cotu)]

species <- cotu$Species
eload <- cotu$E_load

indval = multipatt(indiabun, species, func = "r.g", control = how(nperm=999)) #By using abundance data and not presence-absence we are calculating the "point biserial correlation coefficient"
indval
summary(indval, indvalcomp = TRUE)

#round(head(indval$str), 7)
```

```{r, Type I errror and data table, tidy = TRUE} 
#Correcting for type 1 error and multiple comparisons
#code from this post
#https://stats.stackexchange.com/questions/370724/indiscpecies-multipatt-and-overcoming-multi-comparrisons/401277#401277


#extract table of stats
indval.sign <- as.data.table(indval$sign, keep.rownames=TRUE)

#add adjusted p-value
indval.sign[ , p.value.bh :=   p.adjust(p.value, method="BH")] #This can also be calculated with `dplyr` and `tidyr`
#indval.table <- indval.sign %>%
  #mutate(p.value.bh = p.adjust(p.value, method = "BH"))

#now can select only the indicators with adjusted significant p-values
indval.sign[p.value.bh <= 0.05,]

#renaming the first column
colnames(indval.sign)[1]  <- "OTU" 
```

P-value adjustments are computed with the "BH" method. Which "[...] control the false discovery rate, the expected proportion of false discoveries amongst the rejected hypotheses. The false discovery rate is a less stringent condition than the family-wise error rate, so these methods are more powerful than the others." Information for the R documentation page of `p.adjust()`.

Table with taxonomic information. These are OTUs that are significantly correlated with tree species across the whole data set *n* = 156 (individuals that where used for ant and pathogen assay).
```{r, Table of sigficantly correlated species, tidy = TRUE}

indispp_table <- left_join(newpqDF, indval.sign, by= c("OTU"))

indispp_table <- indispp_table %>%
  filter(p.value.bh <= 0.05) %>%
  select(!c(9:164)) 

#write.csv(indispp_table, "Significant_OTUs.csv")

paged_table(indispp_table)
```

## Indicator species on samples with the **highest and lowest diversity**

Sorting samples with the highest diversity per species (top 10% per species). 
If it is not done this way we end up with the top 10% of the whole data set and that turns out to be *Theobroma cacao*. Similar for the bottom 10%.

```{r, Ant data set top/bottom 3, tidy = TRUE}
# n <- 0.1 * nrow(master)

# 3 plants with highest Shannon diversity
antop3 <- masterant %>%
  group_by(Species) %>%
  slice_max(order_by = Shannon, n = 3) %>%
  select(Species, Sample_name, E_load, Shannon)
#Top 3 plants with the highest FEF diversity per Species.

  
  #  group_by(Species) %>%
  # summarise(across(c(Sample_name, E_load, Shannon), .fns = ~sort(.x, decreasing = T)[1:3])) #Old way of filtering the data. It selected the top 3 values for Sample_name and then Shannon, which then mismatched Samples with Shannon values. 



# 3 plants with the lowest Shannon diversity
anbot3 <- masterant %>%
  group_by(Species) %>%
  slice_min(order_by = Shannon, n = 3) %>%
  select(Species, Sample_name, E_load, Shannon)

#This data frame is meant to be used as a filter to select samples from community data frame (cotu).

```

After trying to capture the samples with the top 10% diversity I realize that on a per species level that would mean 1 plant per species. There are 10 plant/samples per species and 7 tree species. I changed the approach. Now we are looking at the 3 most diverse samples per tree species. The same method will be applied to the lowest 10%.

We see that 4/21 are E-:E+ are selected as the top 3 with the highest diversity. While, the lowest diversity plants are split 11/21 E-:E+. We are selecting the top 3 of the data frame for ant and pathogen assays respectively.

```{r, Pathogen top/bottom 3, tidy = TRUE}
#n <- ,0.1 * nrow(masterpat)

#Top 3
pat_simple <- masterpat %>% #Formatting the data frame to be lite the `masterant` df so I can then apply the code to selest the top 3 most diverse samples per tree species. 
  group_by(Species, Sample_name, E_load) %>%
 summarise(across(c(4:13), mean))

boxplot(Shannon ~ E_load, data = pat_simple)

patop3 <- pat_simple %>% #Now it's like the ant df.
  group_by(Species) %>%
  slice_max(order_by = Shannon, n = 3) %>%
  select(Species, Sample_name, E_load, Shannon)
  
  
#Top 3 plants with the highest FEF diversity per Species.

# 3 plants with the lowest Shannon diversity
pabot3 <- pat_simple %>%
  group_by(Species) %>%
  slice_min(order_by = Shannon, n = 3) %>%
  select(Species, Sample_name, E_load, Shannon)
#This data frame is meant to be used as a filter to select samples from community data frame (cotu).
```

Of the plants used in the pathogen trial with the highest diversity 5/21 are E-:E+. While the lowest diversity plant are split 10/21 E-:E+

### Filtering the community data frame with the top/bottom 3 

```{r, Ant and Pathogen filtering, tidy = TRUE}
#Top 3 ant
antop_filter <- semi_join(cotu, antop3, by= c("Sample_name"))

#Filtering `cotu` with `antop3`
filter_filter <- anti_join(antop3, antop_filter, by = c("Sample_name")) #should turn 0

#Bottom 3 ant
anbot_filter <- semi_join(cotu, anbot3, by= c("Sample_name")) 
filter_filter <- anti_join(anbot3, anbot_filter, by = c("Sample_name")) 

# Top 3 pathogen
patop_filter <- semi_join(cotu, patop3, by= c("Sample_name")) 
filter_filter <- anti_join(patop3, patop_filter, by = c("Sample_name")) 

#Bottom 3 pathogen
pabot_filter <- semi_join(cotu, pabot3, by= c("Sample_name")) 
filter_filter <- anti_join(pabot3, pabot_filter, by = c("Sample_name"))
```

### Ant Indicator Species

```{r, top-Bottom ant indicator species, tidy = TRUE}
#Ant assay data
#Making vector of groups for analysis
top_ant <- antop_filter[, 4:ncol(antop_filter)]

species2 <- antop_filter$Species

ant_indi = multipatt(top_ant, species2, func = "r.g", control = how(nperm=999)) #By using abundance data and not presence-absence we are calculating the "point biserial correlation coefficient"

summary(ant_indi, indvalcomp = TRUE)


#bottom 3
bot_ant <- anbot_filter[,4:ncol(anbot_filter)]

species3 <- anbot_filter$Species

botant <- multipatt(bot_ant, species3, func = "r.g", control = how(nperm = 999))

summary(botant, indvalcomp = TRUE)
```

```{r, Type I error and data table for ant, tidy = TRUE}
#Top-ant
#extract table of stats
ant.sign <- as.data.table(ant_indi$sign, keep.rownames=TRUE)
ant_indi$sign
#add adjusted p-value
ant.sign[ , p.value.bh :=   p.adjust(p.value, method="BH")] #This can also be calculated with `dplyr` and `tidyr`
# It doesn't make much sense here to adjust the p-value because the groups(species) are small. 

#now can select only the indicators with significant p-values
ant.sign[p.value <= 0.05,]

#renaming the first column
colnames(ant.sign)[1]  <- "OTU" 

#Bot-ant
botant.sign <- as.data.table(botant$sign, keep.rownames=TRUE)

#add adjusted p-value
botant.sign[ , p.value.bh :=   p.adjust(p.value, method="BH")] #This can also be calculated with `dplyr` and `tidyr`

#now can select only the indicators with significant p-values
botant.sign[p.value <= 0.05,]

#renaming the first column
colnames(botant.sign)[1]  <- "OTU" 

```

It doesn't make much sense here to adjust the p-value because the groups(Species) in ant highest/lowest selection are small.

```{r, ANT top Table of sigficantly correlated species, tidy = TRUE}

# Top
antspp_table <- left_join(newpqDF, ant.sign, by= c("OTU"))

antspp_table <- antspp_table %>%
  filter(p.value <= 0.05) %>%
  select(!c(9:164)) 

#write.csv(antspp_table, "top_ant_OTUs.csv")
paged_table(antspp_table)

# Bottom
botantspp_table <-  left_join(newpqDF, botant.sign, by= c("OTU"))

botantspp_table <- botantspp_table %>%
  filter(p.value <= 0.05) %>%
  select(!c(9:164)) 

#write.csv(botantspp_table, "bottom_ant_OTUs.csv")  
paged_table(botantspp_table)

```

### Pathogen Indicator Species

```{r, Highest-Lowest Diversity pathogen indicator species, tidy = TRUE}
#Ant assay data
#Making vector of groups for analysis
top_pat <- patop_filter[, 4:ncol(patop_filter)]

species4 <- patop_filter$Species

patop_indi = multipatt(top_pat, species4, func = "r.g", control = how(nperm=999)) #By using abundance data and not presence-absence we are calculating the "point biserial correlation coefficient"

summary(patop_indi, indvalcomp = TRUE)


#bottom 3
pabot <- pabot_filter[,4:ncol(pabot_filter)]

species5 <- pabot_filter$Species

botpat <- multipatt(pabot, species5, func = "r.g", control = how(nperm = 999))

summary(botant, indvalcomp = TRUE)
```

```{r, Type I error and data table for pathogen, tidy = TRUE}
#Highest Diversity in pathogen samples

#extract table of stats

patop.sign <- as.data.table(patop_indi$sign,  keep.rownames=TRUE) #Indicator/correlation species analysis as table

#add adjusted p-value
patop.sign[ , p.value.bh :=   p.adjust(p.value, method="BH")] #This can also be calculated with `dplyr` and `tidyr`
# It doesn't make much sense here to adjust the p-value because the groups(species) are small. 

#now can select only the indicators with significant p-values
patop.sign[p.value <= 0.05,]

#renaming the first column
colnames(patop.sign)[1]  <- "OTU" 


#Lowest diversity samples in pathogen samples

botpat.sign <- as.data.table(botpat$sign, keep.rownames=TRUE) #Indicator/correlation species analysis as table

#add adjusted p-value
botpat.sign[ , p.value.bh :=   p.adjust(p.value, method="BH")] #This can also be calculated with `dplyr` and `tidyr`
# It doesn't make much sense here to adjust the p-value because the groups(species) are small. 

#now can select only the indicators with significant p-values
botpat.sign[p.value <= 0.05,]

#renaming the first column
colnames(botpat.sign)[1]  <- "OTU" 

```

```{r, Pathogen top Table of sigficantly correlated species, tidy = TRUE}

# Highest diversity in pathogen samples
patspp_table <- left_join(newpqDF, patop.sign, by= c("OTU"))

patspp_table <- patspp_table %>%
  filter(p.value <= 0.05) %>%
  select(!c(9:164)) 

#write.csv(patspp_table, "top_pathogen_OTUs.csv")

paged_table(patspp_table)

# Lowest diversity in pathogen samples
botpatspp_table <-  left_join(newpqDF, botpat.sign, by= c("OTU"))

botpatspp_table <- botpatspp_table %>%
  filter(p.value <= 0.05) %>%
  select(!c(9:164)) 

#write.csv(botpatspp_table, "bottom_pathogen_OTUs.csv")

paged_table(botpatspp_table)
  
```



## Indicator species analysis selected by **leaf damage**

Sorting samples with the highest/lowest leaf damage per species (upper 70% and lower 30% per species) then conducting indicator/correlation species analysis in subset of samples.


```{r, Ant data set upper/lower, tidy = TRUE}
 #n <- 0.1 * nrow(master)

#Highest >70%
lantop <- masterant %>%
  group_by(Species) %>%
  filter(Ant_percent_leafloss > 70) %>%
  summarise(across(c(Sample_name, E_load, Ant_percent_leafloss))) #Plants with more than 70% leaf damage by ant herbivory per tree Species.

#Lowest < 30%
lanbot <- masterant %>%
  group_by(Species) %>%
  filter(Ant_percent_leafloss < 30) %>%
  summarise(across(c(Sample_name, E_load, Ant_percent_leafloss))) #Plants with less than 30% leaf damage by ant herbivory per tree Species.

#This data frame is meant to be used as a filter to select samples from community data frame (cotu).

```

Some species had about half the individuals experience less that 30% leaf damage. For the highest 70% damaged, 5/13 are E+ plants. 

```{r, Pathogen upper/lower, tidy = TRUE}
#n <- ,0.1 * nrow(masterpat)

#I will not using `pat_simple` df here. Using `masterpat`.

# Highest > 30%
lpatop <- masterpat %>% #Now it's like the ant df.
  group_by(Species) %>%
  filter(Pathogen_percent_damage > 30) %>%
  summarise(across(c(Sample_name, E_load, Treatment, Pathogen_percent_damage)))
  
#No plants experienced >70% leaf damage by pathogen.
hist(masterpat$Pathogen_percent_damage) # Look at this histogram. All, except one, are below 40%. Change strategies.

# Lowest < 30%
lpabot <- masterpat %>%
  group_by(Species) %>%
  filter(Pathogen_percent_damage < 30) %>%
  summarise(across(c(Sample_name,Treatment, Pathogen_percent_damage)))
#This data frame is meant to be used as a filter to select samples from community data frame (cotu).
```


The pathogen data set (`masterpat`) shows less than 40% leaf damage for almost all plants, controls and treatments ($114/128$). The focus here is comparing control and treatment leaf across E+ and E- treatments. The cut off here will be 30%. What is below? The E+ samples or the E-? 
It looks like 14 trees have more than 30% leaf damage and $5/14$ are E-. We expected the opposite: more damage on tree with less FEF abundance.



### Filtering the community data frame with the highest/lowest leaf area damaged. 

```{r, Ant and Pathogen filtering damage, tidy = TRUE}
#Highest leaf damage ant
lantop_filter <- semi_join(cotu, lantop, by= c("Sample_name"))

#Filtering `cotu` with `antop3`
filter_filter <- anti_join(lantop, lantop_filter, by = c("Sample_name")) #should turn 0

#Lowest leaf damage ant
lanbot_filter <- semi_join(cotu, lanbot, by= c("Sample_name")) 
filter_filter <- anti_join(lanbot, lanbot_filter, by = c("Sample_name")) 

# Highest leaf damage pathogen
lpatop_filter <- semi_join(cotu, lpatop, by= c("Sample_name")) 
filter_filter <- anti_join(lpatop, lpatop_filter, by = c("Sample_name")) 

#Lowest leaf damage pathogen
lpabot_filter <- semi_join(cotu, lpabot, by= c("Sample_name")) 
filter_filter <- anti_join(lpabot, lpabot_filter, by = c("Sample_name"))
```

### Leaf damage: Ant Indicator Species

```{r, Highest/lowest leaf damage ant indicator species, tidy = TRUE}
#Ant assay data
#Making vector of groups for analysis
ltop_ant <- lantop_filter[, 4:ncol(lantop_filter)]

species7 <- lantop_filter$Species

lant_indi = multipatt(ltop_ant, species7, func = "r.g", control = how(nperm=999))

#By using abundance data and not presence-absence we are calculating the "point biserial correlation coefficient"

summary(lant_indi, indvalcomp = TRUE)

#Lowest leaf damage ant
lbot_ant <- lanbot_filter[,4:ncol(lanbot_filter)]

species8 <- lanbot_filter$Species

lbotant <- multipatt(lbot_ant, species8, func = "r.g", control = how(nperm = 999))

summary(lbotant, indvalcomp = TRUE)
lbotant$sign
```

Indicator/correlation species analysis for samples with the highest leaf damage (>70%) (*n* = 13) returns no OTUs siginificantly correlated with tree species. 

```{r, Type I error and data table for ant leaf damage, tidy = TRUE}
#Top-ant
#extract table of stats
lant.sign <- as.data.table(lant_indi$sign, keep.rownames=TRUE)
lant_indi$sign
#add adjusted p-value
lant.sign[ , p.value.bh :=   p.adjust(p.value, method="BH")] #This can also be calculated with `dplyr` and `tidyr`
# It doesn't make much sense here to adjust the p-value because the groups(species) are small. 

#now can select only the indicators with significant p-values
lant.sign[p.value <= 0.05,]

#renaming the first column
colnames(lant.sign)[1]  <- "OTU" 

#Lowest leaf damage ant
lbotant.sign <- as.data.table(lbotant$sign, keep.rownames=TRUE)

#add adjusted p-value
lbotant.sign[ , p.value.bh :=   p.adjust(p.value, method="BH")] #This can also be calculated with `dplyr` and `tidyr`
# It doesn't make much sense here to adjust the p-value because the groups(species) are small. 

#now can select only the indicators with significant p-values
lbotant.sign[p.value <= 0.05,]

#renaming the first column
colnames(lbotant.sign)[1]  <- "OTU" 

```

```{r, Ant Leaf damage Table of sigficantly correlated species, tidy = TRUE}

# Highest leaf damage ant
lantspp_table <- left_join(newpqDF, lant.sign, by= c("OTU"))

lantspp_table <- lantspp_table %>%
  filter(p.value <= 0.05) %>%
  select(!c(9:164)) 

#write.csv(lantspp_table, "highestleafdamage_ant_OTUs.csv")
paged_table(lantspp_table)

# Bottom
lbotantspp_table <-  left_join(newpqDF, lbotant.sign, by= c("OTU"))

lbotantspp_table <- lbotantspp_table %>%
  filter(p.value <= 0.05) %>%
  select(!c(9:164)) 

#write.csv(botantspp_table, "lowestleafdamage_ant_OTUs.csv")  

paged_table(lbotantspp_table)

```

### Leaf damage: Pathogen Indicator Species

```{r, Highest/lowest pathogen indicator species, tidy = TRUE}
#Pathogen assay data
#Highest leaf damage by pathogen
#Making vector of groups for analysis
ltop_pat <- lpatop_filter[, 4:ncol(lpatop_filter)]

species9 <- lpatop_filter$Species

lpatop_indi = multipatt(ltop_pat, species9, func = "r.g", control = how(nperm=999)) #By using abundance data and not presence-absence we are calculating the "point biserial correlation coefficient"

summary(lpatop_indi, indvalcomp = TRUE)
 

#Lowest leaf damage by pathogen
lpabot <- lpabot_filter[,4:ncol(lpabot_filter)]

species10 <- lpabot_filter$Species

lbotpat <- multipatt(lpabot, species10, func = "r.g", control = how(nperm = 999))

summary(lbotpat, indvalcomp = TRUE)
```

Zero OTUs significantly correlated with the leaves that were damaged >30% by pathogen. On the other hand, 82 OTUs are significantly correlated with plants that experienced <30% leaf damage. 


```{r, Leaf damage Type I error and data table for pathogen, tidy = TRUE}
#Highest leaf damage by pathogen
#extract table of stats
lpatop.sign <- as.data.table(lpatop_indi$sign, keep.rownames=TRUE)

#add adjusted p-value
lpatop.sign[ , p.value.bh :=   p.adjust(p.value, method="BH")] #This can also be calculated with `dplyr` and `tidyr`
# It doesn't make much sense here to adjust the p-value because the groups(species) are small. 

#now can select only the indicators with significant p-values
lpatop.sign[p.value <= 0.05,]

#renaming the first column
colnames(lpatop.sign)[1]  <- "OTU" 


#Lowest leaf damage by pathogen

lbotpat.sign <- as.data.table(lbotpat$sign, keep.rownames=TRUE)

#add adjusted p-value
lbotpat.sign[ , p.value.bh :=   p.adjust(p.value, method="BH")] #This can also be calculated with `dplyr` and `tidyr`
# It doesn't make much sense here to adjust the p-value because the groups(species) are small. 

#now can select only the indicators with significant p-values
lbotpat.sign[p.value <= 0.05,]

#renaming the first column
colnames(lbotpat.sign)[1]  <- "OTU" 

```

```{r, Tables for highest/lowest leaf damage by Pathogen of sigficantly correlated species, tidy = TRUE}

#Highest
lpatspp_table <- left_join(newpqDF, lpatop.sign, by= c("OTU"))

lpatspp_table <- lpatspp_table %>%
  filter(p.value <= 0.05) %>%
  select(!c(9:164)) 

#write.csv(lpatspp_table, "highestleafdamage_pathogen_OTUs.csv")

paged_table(lpatspp_table)

#Lowest
lbotpatspp_table <-  left_join(newpqDF, lbotpat.sign, by= c("OTU"))

lbotpatspp_table <- lbotpatspp_table %>%
  filter(p.value.bh <= 0.05) %>%
  select(!c(9:164)) 

#write.csv(lbotpatspp_table, "lowestleafdamage_pathogen_OTUs.csv")

paged_table(lbotpatspp_table)
  
```

The plants least damaged by pathogen have 92 OTUs significantly correlated with them (*p-value* < 0.05). When adjusted for multiples comparison ("bh") the result is 20 OTUs.


## Time analysis
### Betapart -- Beta diversity over time 
<!-- Code for Boli adapted from Ch1 - Mareli's dissertation. -->

<!-- ```{r, beta} -->
<!-- library(betapart) -->

<!-- # Making df for this analysis (Mainly to retain the sample ID information) -->
<!-- botu <- left_join(cOTU, ndata2, by = "Sample_name") %>% -->
<!--   select(!c(Anthocyanins, -->
<!--             Thickness, -->
<!--             Toughness, -->
<!--             LMA, -->
<!--             Species, -->
<!--             E_load)) %>% -->
<!--   mutate(unique_id = paste(Sample_name, "_", Trial_Code,"_", Trial_type)) %>% -->
<!--   relocate(unique_id, .before = Sample_name) %>% -->
<!--   select(!c(Sample_name, Trial_Code, Trial_type)) -->


<!-- # Subsetting cOTU data frame into subset df's by each tree species -->

<!-- spec_otu <- botu %>% -->
<!--   column_to_rownames(var = "unique_id") -->

<!-- ape_otu <- spec_otu[rownames(spec_otu) %like% "APE",] -->
<!-- dyp_otu <- spec_otu[rownames(spec_otu) %like% "DYP",] -->
<!-- cor_otu <- spec_otu[rownames(spec_otu) %like% "COR",] -->
<!-- chry_otu <- spec_otu[rownames(spec_otu) %like% "CHRY",] -->
<!-- theo_otu <- spec_otu[rownames(spec_otu) %like% "THEO",] -->
<!-- heis_otu <- spec_otu[rownames(spec_otu) %like% "HEI",] -->
<!-- lac_otu <- spec_otu[rownames(spec_otu) %like% "LAC",] -->

<!-- ``` -->

<!-- ```{r, Data frames with dates} -->
<!-- ndata3 <- data %>% -->
<!--   group_by(Species, Unique_ID, Trial_type, Trial_date,Inoculation_date, E_load, Leaf_ID) %>% -->
<!--   summarise(Anthocyanins..aci. = mean(Anthocyanins..aci., na.rm = TRUE), -->
<!--             Thickness..micro.m. = mean(Thickness..micro.m., na.rm = TRUE), -->
<!--             Toughness..lbf. = mean(Toughness..lbf., na.rm = TRUE), -->
<!--             LMA_dw = mean(LMA_dw, na.rm = TRUE), -->
<!--             Abundance_Proportion_day3 = mean(Abundance_Proportion_day3, na.rm = TRUE), -->
<!--             Abundance_Proportion_day7 = mean(Abundance_Proportion_day7, na.rm = TRUE)) %>% -->
<!--   rename( Anthocyanins = Anthocyanins..aci., -->
<!--           Thickness = Thickness..micro.m., -->
<!--           Toughness =Toughness..lbf., -->
<!--           LMA = LMA_dw, -->
<!--           Abun_3 = Abundance_Proportion_day3, -->
<!--           Abun_7 = Abundance_Proportion_day7) %>% -->
<!--   ungroup() %>% -->
<!--    mutate_if(is.character, as.factor) %>% -->
<!--   na.omit() %>% -->
<!--   na.fail() -->

<!-- # Data frame for time analyses (contains date) -->
<!-- ndata4 <- ndata3 %>% -->
<!--   separate(Unique_ID, c("Trial_Code", "ELoad", "Species2", "Replicate")) %>% -->
<!--   unite("Sample_name", Species2:Replicate, sep = "") %>% -->
<!--   relocate(Species, Trial_Code,.after = Sample_name) %>% -->
<!--   select(!c(ELoad, Abun_3, Abun_7)) %>% -->
<!--   mutate_if(is.character, as.factor) %>% -->
<!--   group_by(Sample_name, Species, Trial_type, Trial_date, Inoculation_date, Trial_Code, E_load) %>% -->
<!--   summarise(Anthocyanins = mean(Anthocyanins, na.rm = TRUE), -->
<!--             Thickness = mean(Thickness, na.rm = TRUE), -->
<!--             Toughness = mean(Toughness, na.rm =TRUE), -->
<!--             LMA = mean(LMA, na.rm = TRUE)) -->
<!-- ``` -->

<!-- ```{r, betapart analysis, tidy = TRUE} -->

<!-- # Apeiba -->
<!-- ## Sorting rows -->
<!-- ape_otu_sort <- sort(rownames(ape_otu)) -->
<!-- ape_otu <- ape_otu[ape_otu_sort,] -->

<!-- #Analysis -->
<!-- ape_betapart <- beta.pair.abund(ape_otu, index.family = "bray") -->
<!-- ape_bal <- as.data.frame(as.matrix(ape_betapart$beta.bray.bal)) -->
<!-- ape_gra <- as.data.frame(as.matrix(ape_betapart$beta.bray.gra)) -->
<!-- ape_beta <- as.data.frame(as.matrix(ape_betapart$beta.bray)) -->

<!-- #Saving -->
<!-- # write.csv(ape_bal, row.names = TRUE, "betapart/ape_bal.csv") -->
<!-- # write.csv(ape_gra, row.names = TRUE, "betapart/ape_gra.csv") -->
<!-- # write.csv(ape_beta, row.names = TRUE, "betapart/ape_beta.csv") -->

<!-- # Heisteria -->
<!-- ## Sorting rows -->
<!-- heis_otu_sort <- sort(rownames(heis_otu)) -->
<!-- heis_otu <- heis_otu[heis_otu_sort,] -->

<!-- #Analysis -->
<!-- heis_betapart <- beta.pair.abund(heis_otu, index.family = "bray") -->
<!-- heis_bal <- as.data.frame(as.matrix(heis_betapart$beta.bray.bal)) -->
<!-- heis_gra <- as.data.frame(as.matrix(heis_betapart$beta.bray.gra)) -->
<!-- heis_beta <- as.data.frame(as.matrix(heis_betapart$beta.bray)) -->


<!-- #Saving -->
<!-- # write.csv(heis_bal,  row.names = TRUE, "betapart/heis_bal.csv") -->
<!-- # write.csv(heis_gra,  row.names = TRUE, "betapart/heis_gra.csv") -->
<!-- # write.csv(heis_beta,  row.names = TRUE, "betapart/heis_beta.csv") -->

<!-- # Cordia -->
<!-- ## Sorting rows -->
<!-- cor_otu_sort <- sort(rownames(cor_otu)) -->
<!-- cor_otu <- cor_otu[cor_otu_sort,] -->

<!-- #Analysis -->
<!-- cor_betapart <- beta.pair.abund(cor_otu, index.family = "bray") -->
<!-- cor_bal <- as.data.frame(as.matrix(cor_betapart$beta.bray.bal)) -->
<!-- cor_gra <- as.data.frame(as.matrix(cor_betapart$beta.bray.gra)) -->
<!-- cor_beta <- as.data.frame(as.matrix(cor_betapart$beta.bray)) -->

<!-- #Saving -->
<!-- # write.csv(cor_bal,  row.names = TRUE, "betapart/cor_bal.csv") -->
<!-- # write.csv(cor_gra,  row.names = TRUE, "betapart/cor_gra.csv") -->
<!-- # write.csv(cor_beta,  row.names = TRUE, "betapart/cor_beta.csv") -->

<!-- # Chrysanthenum -->
<!-- # ## Sorting rows -->
<!-- chry_otu_sort <- sort(rownames(chry_otu)) -->
<!-- chry_otu <- chry_otu[chry_otu_sort,] -->

<!-- # Analysis -->
<!-- chry_betapart <- beta.pair.abund(chry_otu, index.family = "bray") -->
<!-- chry_bal <- as.data.frame(as.matrix(chry_betapart$beta.bray.bal)) -->
<!-- chry_gra <- as.data.frame(as.matrix(chry_betapart$beta.bray.gra)) -->
<!-- chry_beta <- as.data.frame(as.matrix(chry_betapart$beta.bray)) -->


<!-- #Saving -->
<!-- # write.csv(chry_bal,  row.names = TRUE, "betapart/chry_bal.csv") -->
<!-- # write.csv(chry_gra,  row.names = TRUE, "betapart/chry_gra.csv") -->
<!-- # write.csv(chry_beta, row.names = TRUE, "betapart/chry_beta.csv") -->

<!-- # Lacmelia -->
<!-- ## Sorting rows -->
<!-- lac_otu_sort <- sort(rownames(lac_otu)) -->
<!-- lac_otu <- lac_otu[lac_otu_sort,] -->

<!-- #Analysis -->
<!-- lac_betapart <- beta.pair.abund(lac_otu, index.family = "bray") -->
<!-- lac_bal <- as.data.frame(as.matrix(lac_betapart$beta.bray.bal)) -->
<!-- lac_gra <- as.data.frame(as.matrix(lac_betapart$beta.bray.gra)) -->
<!-- lac_beta <- as.data.frame(as.matrix(lac_betapart$beta.bray)) -->

<!-- #Saving -->
<!-- # write.csv(lac_bal,  row.names = TRUE, "betapart/lac_bal.csv") -->
<!-- # write.csv(lac_gra,  row.names = TRUE, "betapart/lac_gra.csv") -->
<!-- # write.csv(lac_beta,  row.names = TRUE, "betapart/lac_beta.csv") -->


<!-- # Theobroma -->
<!-- ## Sorting rows -->
<!-- theo_otu_sort <- sort(rownames(theo_otu)) -->
<!-- theo_otu <- theo_otu[theo_otu_sort,] -->

<!-- #Analysis -->
<!-- theo_betapart <- beta.pair.abund(theo_otu, index.family = "bray") -->
<!-- theo_bal <- as.data.frame(as.matrix(theo_betapart$beta.bray.bal)) -->
<!-- theo_gra <- as.data.frame(as.matrix(theo_betapart$beta.bray.gra)) -->
<!-- theo_beta <- as.data.frame(as.matrix(theo_betapart$beta.bray)) -->


<!-- #Saving -->
<!-- # write.csv(theo_bal,  row.names = TRUE, "betapart/theo_bal.csv") -->
<!-- # write.csv(theo_gra,  row.names = TRUE, "betapart/theo_gra.csv") -->
<!-- # write.csv(theo_beta,  row.names = TRUE, "betapart/theo_beta.csv") -->

<!-- # Dypterix -->
<!-- # ## Sorting rows -->
<!-- dyp_otu_sort <- sort(rownames(dyp_otu)) -->
<!-- dyp_otu <- dyp_otu[dyp_otu_sort,] -->

<!-- #Analysis -->
<!-- dyp_betapart <- beta.pair.abund(dyp_otu, index.family = "bray") -->
<!-- dyp_bal <- as.data.frame(as.matrix(dyp_betapart$beta.bray.bal)) -->
<!-- dyp_gra <- as.data.frame(as.matrix(dyp_betapart$beta.bray.gra)) -->
<!-- dyp_beta <- as.data.frame(as.matrix(dyp_betapart$beta.bray)) -->

<!-- #Saving -->
<!-- # write.csv(dyp_bal, row.names = TRUE, "betapart/dyp_bal.csv") -->
<!-- # write.csv(dyp_gra, row.names = TRUE, "betapart/dyp_gra.csv") -->
<!-- # write.csv(dyp_beta, row.names = TRUE, "betapart/dyp_beta.csv") -->
<!-- ``` -->


# END





<!-- ### Discussion -->

<!-- The best fit model is M2.gls. It report and AIC value of -370.46, which is extremely low, but for AIC, the lower the better. The model validation with maximum likelihood, focusing on p-value, results in various interaction effects being significant and worth keeping in the model. Nonetheless, the resulting model, M2.VALID after when the fixed effects and the interactions effects from model validation are kept and performed again, the AIC value increases to -134.59. This possibly indicates that not all the significant interactions were kept. Further analysis of the data need to be conducted to see first best fit model is achieved. I assume the data is not nested and no variance structure was established. According to the current results, all main fixed effects are significant when considering endophyte abundance, prediction of endophyte abundance. Various interactions effects are significant as well, see ANOVA table below.   -->



<!-- Model         | AIC value -->
<!-- ------------- | ------------- -->
<!-- M4.lme         | -135.7916 -->
<!-- M5.REML         | -138.57 -->





<!--  ANOVA type III table          | numDF | denDF | F-value | p-value -->
<!--  ------------------------------|-------|-------|---------|---------- -->
<!-- (Intercept)                    |   1   |  452  |23.385115| <.0001 -->
<!-- Toughness                      |   1   |  452  |1.541581 | 0.215 -->



<!-- --------------------------------------------------------------------|----------------------------------------------------------------------- -->









<!-- # Preliminary analyses presented at Ecological Analyses course By Dr. Farrer.  -->

<!-- This preliminary analysis focuses on Generalized Linear model selection and best fit for the data available to that date (November 2019). The model selection takes into account the different co-variates and how good they correlate with endophyte abundance. The most important part of this analysis is the resulting PCA. The PCA generate has a lot of the environmental data compiled and will be helpfull when analyzing the ant, pathogen and leaf trait data in conjunction with the DNA sequence data. -->

<!-- ## Introduction, hypotheses and core predictions  -->
<!-- Herbivores and pathogens are natural enemies that can be critical determinants of plant community structure. Atta colombica, a species of leaf-cutting ant and generalist herbivore in the Neotropics, is often a major agent of leaf damage in agroecosystems. It is estimated that leaf-cutter ants, in general, cause $1 billion per year in agricultural losses in agroecosystems of international concern. Leaf traits, such as leaf chemistry, lifespan, toughness, and leaf mas per area are a plant’s first line of defense against herbivory, yet new research has shown that other biotic factors may also play role in defense. Leaf-cutting ants are sensitive to the presence of endophytes in leaf tissue, altering their foraging based on endophyte presence/absence^4^. Although there is not a clear indication of how this interaction is modulated, some suggest this occurs through changes in leaf traits caused by endophytes. Another growing body of research has shown that pathogen induced necrosis in leaves is lessened by endophyte presence^5^. Endophyte-infected leaves are more likely to survive, and suffer less leaf damage, than endophyte-free controls when treated with foliar pathogens. Previously, this has been demonstrated with host-specific pathogens, not generalist pathogens. I hypothesize that, in the tripartite inter-action between endophytes, herbivores and pathogens, endophytes will alter leaf defense (i.e. leaf traits) and the tradeoffs to leaf-cutting ants and leaf necrosis from *Calonectria sp.*, a generalist fungal pathogen.  -->

<!-- My core predictions are: $(1)$ Leaf-cutting ants will remove less plant material from leaves with high-er endophyte abundance and richness, but that this result will be modulated by leaf traits.  I anticipate that leaves with longer lifespans will be less attractive to leaf-cutting ants, but low endophyte abundances may outweigh this selection factor; $(2)$ Pathogen damage will decrease in leaves with high (relative to low) en-dophyte loads (abundance, richness); and $(3)$ Endophyte-mediated defense against both herbivores and path-ogens will be most important in short lived leaves, as long-lived leaves are expected to rely more on intrinsic defense. A total of 7 tropical tree species were grown in the greenhouse. The seven tropical tree species vary in leaf traits as previously established in experimental designs by the Van Bael lab at the Smithsonian Tropical Research Institute in the Republic of Panama. For each tree species, seedlings were grown from seeds from the forest floor. Then 10 individual plants were exposed to 10 nights of spore fall to achieve a high endophyte load (E+) and 10 homologous plant were kept inside greenhouse to maintain a low endophyte load (E-). After treatment, four mature leaves were collected from each of individual plants (E+, E-), three were used to profile endophyte abundance and richness via next generation sequencing (data not presented). To assess leaf-cutter ant damage, I introduce one detached leaf per treatment to an actively foraging leaf-cutter ant colony for a two-hour trial, quantifying ant recruitment and the leaf area removed (data not presented). For pathogen as-says, I introduce an agar plug containing hyphae of Calonectria sp. (treatment), and an agar plug without the pathogen (control) to similarly aged/sized leaves. After four days, I assessed necrosis in leaf tissue. A total of sixteen $2mm × 2mm$ sterilized leaf cuttings were platted in malt agar media for 7 days, for both, leaves used for ant and pathogen trials. At day 3 and day 7 leaf cuttings with fungal hyphae were counted.  -->

<!-- Here I present an analysis of the proportion of leaf endophytes present in E+ and E- treated plants. The following preliminary hypotheses are explored: $H_1:$ Endophyte levels will be significantly different. A standard t- test was performed to test this. $H_2:$ Abundance of foliar endophytes is a function of anthocyanins (ACI), tree species (Species), leaf toughness (Toughness), leaf thickness (Thickness) and leaf mass per area (LMA). I use a general linear mixed model (GLM) to test the effect of ACI, Species, Toughness, Thick-ness, LMA, endophyte load (E_load) as my independent variables (fixed effects) on the abundance of endo-phytes, dependent variable.   -->

<!-- My preliminary predictions are: $(1)$ Plants exposed to 10 night of spore fall (E+) will have signifi-cantly greater endophyte abundance levels. $(2)$ Endophyte abundance will greater in short lived leaves (e.g. less tough, less thick), as long-lived leaves are expected to rely more on intrinsic defense.  -->


<!-- ### Flowchart of data -->
<!-- ```{r} -->
<!-- grViz("digraph flowchart { -->
<!--       # node definitions with substituted label text -->
<!--       node [fontname = Helvetica, shape = rectangle]         -->
<!--       tab1 [label = '@@1'] -->
<!--       tab4 [label = '@@4'] -->
<!--       tab5 [label = '@@5'] -->
<!--       tab7 [label = '@@7'] -->
<!--       tab8 [label = '@@8'] -->
<!--       tab9 [label = '@@9'] -->
<!--       tab10 [label = '@@10'] -->
<!--       tab11 [label = '@@11'] -->
<!--       tab12 [label = '@@12'] -->



<!--       # edge definitions with the node IDs -->
<!--       tab1 -> tab4 -->
<!--       tab1 -> tab5 -->
<!--       tab4 -> tab9 ->tab11 -->
<!--       tab9 -> tab12 -->
<!--       tab10 -> tab11 -->
<!--       tab10 -> tab12 -->
<!--       tab4 -> tab10 -->
<!--       tab5 -> tab7 -->
<!--       tab5 -> tab8  -->
<!--       } -->

<!--       [1]: 'Tropical tree species (n = 7)' -->
<!--       [2]: 'Species 1 (n = 20)' # REMEMBER TO MAKE TABS -->
<!--       [3]: 'Species 2 ...n^th (n = 20)'# REMEMBER TO MAKE TABS -->
<!--       [4]: 'Pathogen trials (n = 5)' -->
<!--       [5]: 'Leaf-cutter ant trials (n = 5)' -->
<!--       [6]: 'Trials (n = 5)' -->
<!--       [7]: 'Endophyte +' -->
<!--       [8]: 'Endophyte -' -->
<!--       [9]: 'Endophyte +' -->
<!--       [10]: 'Endophyte -' -->
<!--       [11]: 'Control' -->
<!--       [12]: 'Pathogen' -->
<!--       ") -->
<!-- ``` -->



<!-- # Extra Code -->

<!-- #### To-do's -->
<!-- ```{r} -->
<!-- # Create SACs -->
<!-- # Calculate abundance and those cool bar plots with the fungal Class -->
<!-- # Bring in the pathogen and herbivory data -->
<!-- ``` -->
<!-- ### Species Accumulation curves using a Bray curtis dissimilarity matrix -->

<!-- The following code needs some work. The SACs do not really work I need to verufy how to compute them for microbial data. As of 05/27/2022 -->

<!-- ```{r} -->
<!-- # Subsetting for rarefaction -->
<!-- APE <- ctbas[ctbas$Species == "APEIME",] -->

<!-- #SAC -->
<!-- data(BCI) -->
<!-- str(BCI) -->
<!-- str(csamp) -->

<!-- #Preparing "csamp.TT" for Species Accumulation curves. -->

<!-- csamp.TT <- as.data.frame(csamp.TT) #Remember to re-run code from previous section if needed for distance based analyses. -->
<!-- csamp.TT[,1:156] <- lapply(csamp.TT[,1:156], as.integer) -->
<!-- rownames(csamp.TT) <- NULL -->

<!-- str(csamp.TT) -->
<!-- str(BCI) -->

<!-- #Examples -->

<!-- #sp1 <- specaccum(BCI) -->
<!-- #sp2 <- specaccum(BCI, "random") -->
<!-- #sp2 -->

<!-- #Rarefaction -->
<!-- #data(BCI) -->
<!-- #S <- specnumber(BCI) # observed number of species -->
<!-- #(raremax <- min(rowSums(csamp.TT))) -->
<!-- #str(raremax) -->
<!-- #Srare <- rarefy(BCI, raremax) -->
<!-- #plot(S, Srare, xlab = "Observed No. OTU's", ylab = "Rarefied No. OTU's") -->
<!-- #abline(0, 1) -->
<!-- #rarecurve(csamp.TT, step = 20, sample = raremax, col = "blue", cex = 0.6) -->

<!-- #Rarefaction gave me a lot of trouble. The "raremax" does not compute well of something and needs "integers". -->

<!-- # SACs -->
<!-- sp1 <- specaccum(csamp.TT, method = "random", permutations = 100,  conditioned =TRUE, gamma = "jack2",  w = NULL) -->

<!-- plot(sp1, ci.type="poly", col="blue", lwd=2, ci.lty=0, ci.col="lightblue") #simple base plot to get an idea. -->
<!-- ``` -->

<!-- ## Statistical analyses of explanatory variables (parametric tests) -->

<!-- MANOVA test because we have two independent variables (tress species and endophyte load) and multiple dependent variables (Anthocyanins, thickness, etc.). In this scenario we are looking for how treatment (E_load) impacts the dependent variables within Species. Remember that: Multivariate analysis of Variance (MANOVA) is a procedure for comparing multivariate sample means. As a multivariate procedure, it is used when there are two or more dependent variables, and is typically followed by significance tests involving individual dependent variables separately. It helps to answer: Do changes in the independent variable(s) have significant effects on the dependent variables? What are the relationships among the dependent variables? What are the relationships among the independent variables? -->
<!-- ```{r} -->
<!-- #MANOVAAp<- manova(cbind(Anthocyanins, -->
<!--                         #Thickness, -->
<!--                         #Toughness, -->
<!--                         #LMA, -->
<!--                        #Abun_7) ~ E_load * Species, data = #newdata) -->


<!-- ``` -->

<!-- #### Summary tables and Post-Hoc tests -->
<!-- ```{r} -->
<!-- #Manova(MANOVAAp) -->
<!-- #anova(MANOVAAp)#This analysis of variance table includes the intercept. -->
<!-- #summary(MANOVAAp, test = "Wilks") -->
<!-- #summary.aov(MANOVAAp, split = list("E_load:Species")) -->
<!-- ``` -->
<!-- The results from that are formatted like the standard ANOVA result, with the between-groups and within-groups mean square, F ratio, and p-value. This does not adjust ##type I error rates for multiple comparisons so be wary of doing this for data dredging. -->

<!-- #### Two way ANOVA's. -->
<!-- Taking a deeper look at the results from "summary.aov" function and performing Tukey HSD tests -->
<!-- ```{r} -->
<!-- # Anthocyanins (aci) #### -->
<!-- anovaRA <- aov(Relative_Abundance ~ E_load * Species, data = master) -->
<!-- anova(anovaRA) -->

<!-- # ACI Tukey tests on the interaction that are significant -->
<!-- TukeyHSD(anovaRA, which = "Species") -->
<!-- TukeyHSD(anovaRA, which = "E_load:Species") -->
<!-- TukeyHSD(anovaRA, which = "E_load") -->

<!-- # Leaf thickness (micrometers) #### -->
<!-- anova.THICK <- aov(newdata$Thickness ~ E_load * Species, data = newdata) -->
<!-- anova(anova.THICK) -->

<!-- # Thickness Tukey tests on the interaction that are significant -->
<!-- TukeyHSD(anova.THICK, which = "Species") -->
<!-- TukeyHSD(anova.THICK, which = "E_load:Species") -->

<!-- # Toughness (lbf) #### -->
<!-- anova.TOUGH <- aov(Toughness ~ E_load * Species, data = newdata) -->
<!-- anova(anova.TOUGH) -->

<!-- # Toghness Tukey tests on the interaction that are significant -->
<!-- TukeyHSD(anova.TOUGH, which = "Species") -->

<!-- # LMA #### -->
<!-- anova.LMA <- aov(LMA ~ E_load * Species, data = newdata) -->
<!-- anova(anova.LMA) -->

<!-- # LMA Tukey tests on the interaction that are significant -->

<!-- TukeyHSD(anova.LMA, which = "E_load") -->
<!-- TukeyHSD(anova.LMA, which = "Species") -->

<!-- # Abundance proportion at day 7  #### -->
<!-- anova.ABU7 <- aov(Abun_7 ~ E_load * Species, data = newdata) -->
<!-- anova(anova.ABU7) -->
<!-- newabun <- aov(Abun_7~E_load, data = newdata) -->
<!-- anova(newabun) -->

<!-- # Tukey tests on the interaction that are significant -->

<!-- TukeyHSD(anova.ABU7, which = "E_load") -->
<!-- TukeyHSD(anova.ABU7, which = "Species") -->
<!-- TukeyHSD(anova.ABU7, which = "E_load:Species") -->
<!-- ``` -->


<!-- #### Class barplots -->

<!-- ```{r} -->
<!-- # How the fuck do I make these? -->

<!-- ggplot(data = master, aes(Species, fill = class)) + -->
<!--   geom_bar() + -->
<!--   facet_wrap(~E_load) -->


<!-- barplot -->
<!-- ``` -->

<!-- ```{r} -->

<!--   #geom_jitter(aes(color = E_load, shape = Species), size = 3, alpha = 0.7)+ -->
<!--   #scale_shape_manual(values=c(15:22)) + -->



<!-- # csamp2 #### -->
<!-- #csamp2 <- read.csv("all_cleaned_at_10_percent.csv") #Using same data frame as "csamp" -->
<!-- #csamp2[,2:157] <- lapply(csamp2[,2:157], as.integer) -->
<!-- #csamp2 <- csamp2 %>% -->
<!--   #rename(OTU_ID = X) %>% -->
<!--   #na.omit() %>% -->
<!--   #na.fail() -->

<!-- #Transpose -->
<!-- #csamp.T <- t(csamp) -->
<!-- #csamp.T <- as.data.frame(csamp.T) %>% -->
<!--   #rownames_to_column() %>% -->
<!--  # rename(Sample_name = rowname) -->
<!-- #csamp.T[,2:1775] <- lapply(csamp.T[,2:1775], as.integer) -->

<!-- #tbas2 -->
<!-- #tbas2 <- read.csv("unite_report2BSDHQZP.csv") #Using the same data set as "tbas". This is to use it as data frame and not "matrix". -->
<!-- #tbas2 <- tbas2 %>% -->
<!--   #dplyr::filter(phylum == "Ascomycota") %>% -->
<!--   #select(-match,-e.value, -percent, -coverage, -bitscore) %>% #eliminating some columns that I am not really using -->
<!--   #na.omit()%>% -->
<!--   #rename( OTU_ID = query) %>% -->
<!--   #na.omit() %>% -->
<!--   #na.fail() -->

<!-- # CTBAS #### -->
<!-- #ctbas -->
<!-- #ctbas<- right_join(ndata2, csamp.T, by = "Sample_name")  #for diversity indices, t-tests and other stats. Not used a lot. -->

<!-- #ctbas2 -->
<!-- #ctbas2 <- right_join(csamp2, tbas2, by = "OTU_ID") %>% -->
<!--    #relocate(kingdom, phylum, class, order, family, genus, species,.after = OTU_ID) -->
<!-- #ctbas2.T <- t(ctbas2) %>% -->
<!--   #na.omit() %>% -->
<!--   #as_tibble() -->

<!-- # Long format #### -->
<!-- #ctbas_long <- ctbas2 %>% -->
<!--   #pivot_longer( -->
<!--     #cols = APE10:THEO09, -->
<!--     #names_to = "Sample_name", -->
<!--     #values_to = "Read_Count", -->
<!--     #values_drop_na = FALSE) -->


<!-- ##################### -->
<!-- # Old code, might be useful #### -->

<!-- #new_ant <- ants %>% -->
<!--   #ungroup() %>% -->
<!--   #select(Species,Unique.ID, E_load, Trial_success, Leaf_area_final) %>% -->
<!--   #rename(Unique_ID = Unique.ID) %>% -->
<!--   #dplyr::filter(Trial_success == 1) %>% -->
<!--   #na.omit() %>% -->
<!--   #na.fail() %>% -->
<!--   #select(Unique_ID, Leaf_area_final) -->

<!-- #new_patho <- patho %>% -->
<!--   #ungroup() %>% -->
<!--   #select(Unique.ID, Treatment_Ctrl_Pathogen, Damage_area) %>% -->
<!--   #rename(Unique_ID = Unique.ID)%>% -->
<!--   #na.omit() %>% -->
<!--   #na.fail() -->
<!--  # new_patho$Damage_area[93] = "" -->
<!--  #new_patho$Damage_area[96] = "" -->
<!--   #new_patho$Damage_area[98] = "" -->
<!-- #new_patho <- new_patho %>% -->
<!-- #  na.omit() %>% -->
<!-- #  na.fail() -->

<!-- #Went back to excel to move some factors from Treatment column to another col for the new pathogen dataframe. -->

<!-- #Converting factors into numbers. -->
<!-- #new_patho$Damage_area <- as.numeric(as.character(new_patho$Damage_area)) -->


<!-- ``` -->

